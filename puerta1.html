<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Sala Romántica — Galería Circular</title>
  <style>
    :root {
      --rose-1: #ff8ab5;
      --rose-2: #ffd1e0;
      --lavender: #e0c7ff;
      --glass: rgba(255, 255, 255, 0.15);
      --btn-bg: linear-gradient(180deg, #ff99cc, #ffe6f0);
      --bg-gradient: radial-gradient(circle at 50% 20%, rgba(255, 150, 180, 0.25), transparent 50%, rgba(30, 15, 50, 0.95));
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg-gradient), #1a0a2a;
      overflow: hidden;
      font-family: 'Segoe UI', Roboto, Arial, sans-serif;
      color: var(--rose-2);
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
      display: block;
      position: relative;
      touch-action: none;
    }
    #overlay {
      position: absolute;
      left: 10px;
      top: 10px;
      z-index: 80;
      padding: 10px;
      border-radius: 12px;
      background: var(--glass);
      backdrop-filter: blur(6px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      max-width: 90%;
    }
    #overlay h3 {
      margin: 0 0 6px 0;
      font-size: clamp(14px, 3.5vw, 16px);
      color: var(--rose-2);
      text-shadow: 0 0 5px rgba(255, 150, 180, 0.6);
    }
    #overlay p {
      margin: 0;
      font-size: clamp(11px, 3vw, 12px);
      color: rgba(255, 230, 240, 0.9);
    }
    .controls {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .btn, .btn-ghost {
      position: relative;
      overflow: hidden;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      border-radius: 10px;
      border: 0;
      cursor: pointer;
      font-weight: 600;
      font-size: clamp(11px, 3vw, 12px);
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .btn {
      background: var(--btn-bg);
      color: #2a0a20;
      box-shadow: 0 4px 15px rgba(255, 120, 180, 0.25);
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(255, 120, 180, 0.35);
    }
    .btn:active {
      transform: translateY(0);
    }
    .btn-ghost {
      background: transparent;
      border: 1px solid rgba(255, 230, 240, 0.2);
      color: var(--rose-2);
      padding: 7px 12px;
    }
    .btn-ghost:hover {
      background: rgba(255, 230, 240, 0.08);
      transform: translateY(-2px);
    }
    .btn:focus {
      outline: 2px solid rgba(255, 120, 180, 0.25);
      outline-offset: 2px;
    }
    .ripple {
      position: absolute;
      border-radius: 999px;
      transform: scale(0);
      animation: rip 0.5s ease-out;
      pointer-events: none;
      background: rgba(255, 230, 240, 0.25);
    }
    @keyframes rip {
      to { transform: scale(2.5); opacity: 0; }
    }
    #credits {
      position: absolute;
      right: 10px;
      bottom: 10px;
      color: var(--rose-2);
      font-size: clamp(9px, 2.5vw, 10px);
      z-index: 5;
      padding: 6px;
      border-radius: 8px;
      background: var(--glass);
      backdrop-filter: blur(4px);
    }
    #hint {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 15px;
      color: var(--rose-2);
      z-index: 5;
      font-size: clamp(9px, 2.5vw, 10px);
      padding: 6px 12px;
      border-radius: 999px;
      background: var(--glass);
      backdrop-filter: blur(4px);
      display: none;
    }
    #previewModal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, rgba(30, 15, 50, 0.7), rgba(20, 10, 30, 0.9));
      z-index: 120;
    }
    #previewContent {
      max-width: 95vw;
      max-height: 90vh;
      padding: 12px;
      border-radius: 12px;
      background: var(--glass);
      display: flex;
      flex-direction: column;
      gap: 10px;
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }
    #previewContent img {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 10px;
      display: block;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      object-fit: contain;
    }
    #previewClose {
      align-self: flex-end;
      padding: 8px 12px;
      border-radius: 10px;
      border: 0;
      background: var(--btn-bg);
      color: #2a0a20;
      cursor: pointer;
      font-size: clamp(11px, 3vw, 12px);
    }
    #romOverlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 30;
      background: radial-gradient(50% 50% at 50% 40%, rgba(255, 150, 180, 0.12), transparent 50%), linear-gradient(180deg, rgba(255, 240, 245, 0.05), transparent 70%);
    }
    #errorMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(0.7rem, 3vw, 0.9rem);
      text-align: center;
      color: var(--rose-1);
      text-shadow: 0 0 8px var(--rose-1);
      z-index: 130;
      display: none;
      padding: clamp(6px, 1.5vw, 8px);
      max-width: 95vw;
      background: rgba(20, 10, 30, 0.8);
      border-radius: 10px;
      backdrop-filter: blur(4px);
    }
    #loadingBarContainer {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: clamp(100px, 60vw, 150px);
      height: 6px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 4px;
      overflow: hidden;
      z-index: 140;
    }
    #loadingBar {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--rose-1), var(--rose-2));
      transition: width 0.3s ease;
    }
    #loadingText {
      position: absolute;
      top: calc(50% + 20px);
      left: 50%;
      transform: translate(-50%, 0);
      color: var(--rose-1);
      font-size: clamp(0.7rem, 2.8vw, 0.9rem);
      text-shadow: 0 0 6px var(--rose-1);
    }
    @media (max-width: 720px) {
      #overlay {
        left: 8px;
        top: 8px;
        padding: 8px;
        width: calc(100% - 16px);
        box-sizing: border-box;
      }
      .btn, .btn-ghost {
        padding: 7px 12px;
        font-size: clamp(10px, 2.8vw, 11px);
      }
      .controls {
        gap: 6px;
        flex-direction: column;
        align-items: flex-start;
      }
      #overlay h3 {
        font-size: clamp(12px, 3.2vw, 14px);
      }
      #overlay p {
        font-size: clamp(10px, 2.8vw, 11px);
      }
      #hint {
        display: block;
        font-size: clamp(9px, 2.5vw, 10px);
        padding: 5px 10px;
      }
      #errorMessage {
        font-size: clamp(0.6rem, 2.8vw, 0.8rem);
        padding: clamp(5px, 1.5vw, 7px);
        max-width: 98vw;
      }
      #loadingBarContainer {
        width: clamp(80px, 50vw, 120px);
        height: 5px;
      }
      #loadingText {
        font-size: clamp(0.6rem, 2.5vw, 0.8rem);
      }
    }
    @media (min-resolution: 2dppx) {
      #canvas-container canvas {
        width: 100vw !important;
        height: 100vh !important;
      }
    }
  </style>
</head>
<body>
  <div id="errorMessage">No creaste tu proyecto. Por favor, crea tu ID primero.</div>
  <div id="loadingBarContainer">
    <div id="loadingBar"></div>
    <div id="loadingText">Cargando...</div>
  </div>
  <div id="canvas-container"></div>
  <div id="romOverlay"></div>
  <div id="overlay" role="region" aria-label="Controles">
    <h3>Sala Romántica — Galería Circular</h3>
    <p>Desliza para rotar. Toca una foto para ampliarla.</p>
    <div class="controls">
      <button id="prevBtn" class="btn">Anterior</button>
      <button id="nextBtn" class="btn">Siguiente</button>
      <button id="toggleAuto" class="btn" aria-pressed="false">Auto-rotar</button>
      <button id="returnBtn" class="btn-ghost">Regresar</button>
    </div>
  </div>
  <div id="credits">Diseño romántico • Imágenes de ejemplo: picsum.photos</div>
  <div id="hint">Desliza para rotar • Toca para ampliar</div>
  <div id="previewModal" aria-hidden="true">
    <div id="previewContent">
      <button id="previewClose">Cerrar</button>
      <img id="previewImage" src="" alt="Vista previa">
    </div>
  </div>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js';
    import { getDatabase, ref, get } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js';
    const firebaseConfig = {
      apiKey: "AIzaSyBk2SVaP1w4V3MWrpp1r3X5Xk9eH06gBt4",
      authDomain: "tunel-de-recuerdos.firebaseapp.com",
      projectId: "tunel-de-recuerdos",
      storageBucket: "tunel-de-recuerdos.firebasestorage.app",
      messagingSenderId: "630660710506",
      appId: "1:630660710506:web:90d34150c9f21f668eca13",
      measurementId: "G-ETFDVEHML1"
    };
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    let imageUrls = [];
    async function fetchImages() {
      const errorMessage = document.getElementById('errorMessage');
      const urlParams = new URLSearchParams(window.location.search);
      const userId = urlParams.get('id')?.trim();
      if (!userId || userId === '') {
        errorMessage.textContent = 'No creaste tu proyecto. Por favor, crea tu ID primero.';
        errorMessage.style.display = 'block';
        document.getElementById('loadingBarContainer').style.display = 'none';
        return [];
      }
      try {
        const snapshot = await get(ref(database, `usuarios/${userId}`));
        if (snapshot.exists()) {
          const data = snapshot.val();
          let allFotos = [];
          for (let i = 1; i <= 5; i++) {
            const fotos = data[`puerta${i}Fotos`] || [];
            allFotos = allFotos.concat(fotos.filter(url => typeof url === 'string' && url.trim() !== ''));
          }
          let validFotos = allFotos.slice(0, 7);
          if (validFotos.length === 0) {
            errorMessage.textContent = 'No hay imágenes en tu galería. Agrega al menos 1 imagen.';
            errorMessage.style.display = 'block';
            document.getElementById('loadingBarContainer').style.display = 'none';
            return [];
          }
          while (validFotos.length < 7) {
            validFotos = validFotos.concat(validFotos.slice(0, Math.min(validFotos.length, 7 - validFotos.length)));
          }
          return validFotos.slice(0, 7);
        } else {
          errorMessage.textContent = 'No creaste tu proyecto. Por favor, crea tu ID primero.';
          errorMessage.style.display = 'block';
          document.getElementById('loadingBarContainer').style.display = 'none';
          return [];
        }
      } catch (error) {
        errorMessage.textContent = 'Error al cargar las imágenes. Por favor, intenta de nuevo.';
        errorMessage.style.display = 'block';
        document.getElementById('loadingBarContainer').style.display = 'none';
        return [];
      }
    }
    (async function() {
      const loadingBarContainer = document.getElementById('loadingBarContainer');
      const loadingBar = document.getElementById('loadingBar');
      const loadingText = document.getElementById('loadingText');
      loadingBarContainer.style.display = 'block';
      loadingText.textContent = 'Cargando...';
      imageUrls = await fetchImages();
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 720;
      const TOTAL_IMAGES = 7;
      const PARTICLES_COUNT = isMobile ? 15 : 40;
      const BASE_FRAME_W = isMobile ? 130 : 240;
      const BASE_FRAME_H = isMobile ? 90 : 160;
      const MIN_CAMERA_DISTANCE = 180;
      const MAX_CAMERA_DISTANCE = 700;
      let loadedImages = 0;
      const totalImages = Math.min(imageUrls.length, 7);
      function updateLoadingProgress() {
        loadedImages++;
        const progress = (loadedImages / totalImages) * 100;
        loadingBar.style.width = `${progress}%`;
        if (loadedImages >= totalImages) {
          setTimeout(() => {
            loadingBarContainer.style.opacity = '0';
            setTimeout(() => {
              loadingBarContainer.style.display = 'none';
              document.getElementById('overlay').style.display = 'block';
              document.getElementById('credits').style.display = 'block';
              document.getElementById('hint').style.display = 'block';
            }, 300);
          }, 500);
        }
      }
      if (totalImages === 0) {
        loadingBarContainer.style.display = 'none';
      } else {
        imageUrls.forEach(url => {
          const img = new Image();
          img.src = url;
          img.onload = updateLoadingProgress;
          img.onerror = () => {
            console.warn(`Error al cargar imagen: ${url}`);
            updateLoadingProgress();
          };
        });
      }
      const container = document.getElementById('canvas-container');
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.display = 'block';
      renderer.domElement.style.touchAction = 'none';
      container.appendChild(renderer.domElement);
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a0a2a);
      scene.fog = new THREE.FogExp2(0x1a0a2a, 0.0006);
      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 4000);
      let cameraDistance = isMobile ? 450 : 350;
      camera.position.set(0, 20, cameraDistance);
      camera.lookAt(0, 0, 0);
      camera.frustumCulled = false; // Prevent culling issues
      const hemi = new THREE.HemisphereLight(0xfff0f5, 0x1a0a2a, 0.65);
      scene.add(hemi);
      const ambient = new THREE.AmbientLight(0xffe8f0, 0.25);
      scene.add(ambient);
      const key = new THREE.PointLight(0xffa0c0, 1.1, 1000);
      key.position.set(350, 120, 120);
      scene.add(key);
      const soft = new THREE.PointLight(0xffc0d5, 0.6, 500);
      soft.position.set(-250, 80, -150);
      scene.add(soft);
      const imagesGroup = new THREE.Group();
      scene.add(imagesGroup);
      const loader = new THREE.TextureLoader();
      loader.setCrossOrigin('');
      function getScaleFactor() {
        return Math.min(1, window.innerWidth / 900);
      }
      function createFramedImage(url, angle, idx) {
        const scaleFactor = getScaleFactor();
        const frameW = BASE_FRAME_W * scaleFactor;
        const frameH = BASE_FRAME_H * scaleFactor;
        const glow = new THREE.Mesh(
          new THREE.PlaneGeometry(frameW * 1.15, frameH * 1.15),
          new THREE.MeshBasicMaterial({ color: 0xffa0c5, transparent: true, opacity: 0.12, side: THREE.DoubleSide })
        );
        const frame = new THREE.Mesh(
          new THREE.BoxGeometry(frameW * 1.04, frameH * 1.04, Math.max(2, Math.round(2 * scaleFactor))),
          new THREE.MeshStandardMaterial({ color: 0x2a0a20, roughness: 0.15, metalness: 0.65 })
        );
        const imgMat = new THREE.MeshBasicMaterial({ color: 0xffffff, map: null });
        const img = new THREE.Mesh(new THREE.PlaneGeometry(frameW - 4, frameH - 4), imgMat);
        const group = new THREE.Group();
        group.frustumCulled = false; // Ensure images stay visible
        glow.position.set(0, 2 * scaleFactor, -0.8);
        frame.position.set(0, 0, -2 * scaleFactor);
        img.position.set(0, 0, 0.8 * scaleFactor);
        group.add(glow);
        group.add(frame);
        group.add(img);
        const radius = isMobile ? 250 : 350;
        group.position.set(
          Math.cos(angle) * radius,
          -15,
          Math.sin(angle) * radius
        );
        group.rotation.y = -angle;
        group.userData = { idx, url };
        loader.load(url, tex => {
          tex.minFilter = THREE.LinearMipmapLinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
          imgMat.map = tex;
          imgMat.needsUpdate = true;
        }, undefined, err => {
          console.warn(`Error al cargar textura: ${url}`, err);
        });
        imagesGroup.add(group);
        return group;
      }
      let currentIndex = 0;
      let targetIndex = 0;
      function arrangeImages() {
        while (imagesGroup.children.length) imagesGroup.remove(imagesGroup.children[0]);
        const total = TOTAL_IMAGES;
        for (let i = 0; i < total; i++) {
          const angle = (i / total) * Math.PI * 2 - (targetIndex * (Math.PI * 2 / total));
          createFramedImage(imageUrls[i % imageUrls.length], angle, i);
        }
      }
      if (imageUrls.length > 0) arrangeImages();
      const particlesGeo = new THREE.BufferGeometry();
      const particlesCount = PARTICLES_COUNT;
      const posArray = new Float32Array(particlesCount * 3);
      for (let i = 0; i < particlesCount; i++) {
        posArray[i * 3] = (Math.random() - 0.5) * 1200;
        posArray[i * 3 + 1] = -120 + Math.random() * 450;
        posArray[i * 3 + 2] = (Math.random() - 0.5) * 1200;
      }
      particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      function createHeartTexture() {
        const s = 20;
        const c = document.createElement('canvas');
        c.width = s;
        c.height = s;
        const cx = c.getContext('2d');
        cx.clearRect(0, 0, s, s);
        cx.fillStyle = 'rgba(255, 140, 180, 0.95)';
        cx.beginPath();
        const x = s / 2, y = s / 2, scale = s / 32;
        cx.moveTo(x, y + 3 * scale);
        cx.bezierCurveTo(x + 8 * scale, y - 6 * scale, x + 14 * scale, y + 6 * scale, x, y + 12 * scale);
        cx.bezierCurveTo(x - 14 * scale, y + 6 * scale, x - 8 * scale, y - 6 * scale, x, y + 3 * scale);
        cx.closePath();
        cx.fill();
        cx.globalCompositeOperation = 'lighter';
        cx.fillStyle = 'rgba(255, 180, 200, 0.25)';
        cx.beginPath();
        cx.arc(x, y + 2 * scale, 24 * scale, 0, Math.PI * 2);
        cx.fill();
        return new THREE.CanvasTexture(c);
      }
      const heartTex = createHeartTexture();
      const particlesMat = new THREE.PointsMaterial({ size: 20 * getScaleFactor(), map: heartTex, transparent: true, alphaTest: 0.04, depthWrite: false });
      const particles = new THREE.Points(particlesGeo, particlesMat);
      scene.add(particles);
      const bursts = [];
      function spawnBurstAt(worldPos, color = 0xffc8d8, count = isMobile ? 2 : 5) {
        for (let i = 0; i < count; i++) {
          const g = new THREE.SphereGeometry(1 + Math.random() * 2 * getScaleFactor(), 4, 4);
          const m = new THREE.MeshBasicMaterial({ color });
          const mesh = new THREE.Mesh(g, m);
          mesh.frustumCulled = false;
          mesh.position.copy(worldPos);
          scene.add(mesh);
          const dir = new THREE.Vector3((Math.random() - 0.5) * 2, 0.4 + Math.random() * 0.6, (Math.random() - 0.5) * 2).normalize();
          const speed = 20 * getScaleFactor() + Math.random() * 50 * getScaleFactor();
          bursts.push({ mesh, vel: dir.multiplyScalar(speed), life: 0.25 + Math.random() * 0.35 });
        }
      }
      let mouse = new THREE.Vector2(0, 0);
      const raycaster = new THREE.Raycaster();
      let hovered = null;
      let isDragging = false, dragStartX = 0, startIndex = 0;
      function onPointerDown(e) {
        isDragging = true;
        const p = getClientPoint(e);
        dragStartX = p.x;
        startIndex = currentIndex;
      }
      function onPointerMove(e) {
        const p = getClientPoint(e);
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((p.x - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((p.y - rect.top) / rect.height) * 2 + 1;
        if (isDragging && (!e.touches || e.touches.length === 1)) {
          const dx = (p.x - dragStartX) / window.innerWidth;
          currentIndex = startIndex + dx * 12;
          targetIndex = currentIndex;
        }
      }
      function onPointerUp() {
        isDragging = false;
        targetIndex = Math.round(currentIndex);
      }
      function getClientPoint(e) {
        if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        if (e.changedTouches && e.changedTouches.length) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      }
      renderer.domElement.addEventListener('pointerdown', onPointerDown, { passive: true });
      renderer.domElement.addEventListener('pointermove', onPointerMove, { passive: true });
      window.addEventListener('pointerup', onPointerUp, { passive: true });
      let pinchStartDist = 0, pinchStartCameraDist = cameraDistance;
      function getTouchDist(e) {
        if (!e.touches || e.touches.length < 2) return 0;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }
      renderer.domElement.addEventListener('touchstart', (e) => {
        if (e.touches && e.touches.length === 2) {
          pinchStartDist = getTouchDist(e);
          pinchStartCameraDist = cameraDistance;
        }
      }, { passive: true });
      renderer.domElement.addEventListener('touchmove', (e) => {
        if (e.touches && e.touches.length === 2) {
          const d = getTouchDist(e);
          if (pinchStartDist > 0) {
            const factor = pinchStartDist / d;
            cameraDistance = pinchStartCameraDist * factor;
            cameraDistance = Math.max(MIN_CAMERA_DISTANCE, Math.min(MAX_CAMERA_DISTANCE, cameraDistance));
          }
        }
      }, { passive: true });
      renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        cameraDistance += e.deltaY * 0.2;
        cameraDistance = Math.max(MIN_CAMERA_DISTANCE, Math.min(MAX_CAMERA_DISTANCE, cameraDistance));
      }, { passive: false });
      function onClick(e) {
        const rect = renderer.domElement.getBoundingClientRect();
        const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX) || (e.changedTouches && e.changedTouches[0] && e.changedTouches[0].clientX);
        const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY) || (e.changedTouches && e.changedTouches[0] && e.changedTouches[0].clientY);
        const target = e.target;
        if (target.closest && target.closest('.btn, .btn-ghost')) createRipple(target.closest('.btn, .btn-ghost'), clientX, clientY);
        const cx = clientX - rect.left;
        const cy = clientY - rect.top;
        const mx = (cx / rect.width) * 2 - 1;
        const my = -((cy / rect.height) * 2 - 1);
        raycaster.setFromCamera({ x: mx, y: my }, camera);
        const ints = raycaster.intersectObjects(imagesGroup.children, true);
        if (ints.length > 0) {
          let obj = ints[0].object;
          while (obj && (!obj.userData || !obj.userData.url)) obj = obj.parent;
          if (obj && obj.userData && obj.userData.url) {
            openPreview(obj.userData.url);
            const world = new THREE.Vector3();
            obj.getWorldPosition(world);
            spawnBurstAt(world);
          }
        }
      }
      renderer.domElement.addEventListener('click', onClick, { passive: true });
      const previewModal = document.getElementById('previewModal');
      const previewImage = document.getElementById('previewImage');
      const previewClose = document.getElementById('previewClose');
      function openPreview(url) {
        previewImage.src = url;
        previewModal.style.display = 'flex';
        previewModal.setAttribute('aria-hidden', 'false');
      }
      function closePreview() {
        previewModal.style.display = 'none';
        previewImage.src = '';
        previewModal.setAttribute('aria-hidden', 'true');
      }
      previewClose.addEventListener('click', closePreview);
      previewModal.addEventListener('click', (e) => {
        if (e.target === previewModal) closePreview();
      });
      function createRipple(button, clientX, clientY) {
        const rect = button.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const r = Math.max(rect.width, rect.height);
        const el = document.createElement('span');
        el.className = 'ripple';
        el.style.width = el.style.height = (r * 1.5) + 'px';
        el.style.left = (x - r * 0.75) + 'px';
        el.style.top = (y - r * 0.75) + 'px';
        button.appendChild(el);
        setTimeout(() => { el.remove(); }, 600);
      }
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      const toggleBtn = document.getElementById('toggleAuto');
      let autoRotate = false;
      prevBtn.addEventListener('click', (e) => {
        createRipple(prevBtn, e.clientX, e.clientY);
        targetIndex += 1;
      });
      nextBtn.addEventListener('click', (e) => {
        createRipple(nextBtn, e.clientX, e.clientY);
        targetIndex -= 1;
      });
      function toggleAutoRotate() {
        autoRotate = !autoRotate;
        toggleBtn.textContent = autoRotate ? 'Detener' : 'Auto-rotar';
        toggleBtn.setAttribute('aria-pressed', String(autoRotate));
      }
      toggleBtn.addEventListener('click', (e) => {
        createRipple(toggleBtn, e.clientX, e.clientY);
        toggleAutoRotate();
      });
      document.getElementById('returnBtn').addEventListener('click', (e) => {
        createRipple(e.currentTarget, e.clientX, e.clientY);
        window.parent.postMessage({ type: 'doorClosed' }, '*');
      });
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closePreview();
      });
      let lastTime = performance.now();
      function animate() {
        requestAnimationFrame(animate);
        const now = performance.now();
        const dt = Math.max(0.001, (now - lastTime) / 1000);
        lastTime = now;
        currentIndex += (targetIndex - currentIndex) * 0.1;
        camera.position.z += (cameraDistance - camera.position.z) * 0.2;
        camera.lookAt(0, 0, 0);
        const posAttr = particles.geometry.getAttribute('position');
        for (let i = 0; i < particlesCount; i++) {
          let idx = i * 3;
          let y = posAttr.array[idx + 1];
          y += (0.5 + Math.sin(i * 0.07 + now * 0.0004) * 0.15) * dt * 5;
          if (y > 600) {
            y = -120 - Math.random() * 160;
            posAttr.array[idx] = (Math.random() - 0.5) * 1200;
            posArray[idx + 2] = (Math.random() - 0.5) * 1200;
          }
          posAttr.array[idx + 1] = y;
        }
        posAttr.needsUpdate = true;
        imagesGroup.children.forEach((g, idx) => {
          const targetAngle = (idx / TOTAL_IMAGES) * Math.PI * 2 - (currentIndex * (Math.PI * 2 / TOTAL_IMAGES));
          const currentAngle = -g.rotation.y;
          let delta = targetAngle - currentAngle;
          while (delta > Math.PI) delta -= Math.PI * 2;
          while (delta < -Math.PI) delta += Math.PI * 2;
          g.rotation.y += delta * 0.15;
          const radius = isMobile ? 250 : 350;
          g.position.x = Math.cos(g.rotation.y) * radius;
          g.position.z = Math.sin(g.rotation.y) * radius;
          g.position.y = -15 + Math.sin(idx + now * 0.0003) * 4;
        });
        for (let i = bursts.length - 1; i >= 0; i--) {
          const b = bursts[i];
          b.life -= dt;
          b.mesh.position.x += b.vel.x * dt;
          b.mesh.position.y += b.vel.y * dt;
          b.mesh.position.z += b.vel.z * dt;
          if (b.mesh.material && b.mesh.material.opacity !== undefined) b.mesh.material.opacity = Math.max(0, b.life / 0.4);
          if (b.life <= 0) {
            scene.remove(b.mesh);
            bursts.splice(i, 1);
          }
        }
        if (autoRotate) {
          targetIndex -= dt * 0.4;
        }
        if (!isMobile) {
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(imagesGroup.children, true);
          if (intersects.length > 0) {
            let obj = intersects[0].object;
            while (obj && (!obj.userData || !obj.userData.url)) obj = obj.parent;
            if (obj && obj !== hovered) {
              if (hovered) hovered.scale && hovered.scale.setScalar(1);
              hovered = obj;
              hovered.scale && hovered.scale.setScalar(1.07);
            }
          } else if (hovered) {
            hovered.scale && hovered.scale.setScalar(1);
            hovered = null;
          }
        }
        renderer.render(scene, camera);
      }
      animate();
      function onResize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        arrangeImages();
      }
      window.addEventListener('resize', onResize);
      window._romanticScene = { arrangeImages, spawnBurstAt, toggleAutoRotate };
    })();
  </script>
</body>
</html>
