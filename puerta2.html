<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puerta 2 — Sala Romántica (estética adaptada)</title>
  <style>
    :root{
      --accent-a:#a6f0ff;
      --accent-b:#ffb3d1;
      --panel: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;background:radial-gradient(1000px 700px at 15% 12%, rgba(170,220,255,0.02), transparent 8%), #040007;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#f7eef6}
    #canvas-container{width:100vw;height:100vh;position:relative;display:block;touch-action:none}
    #overlay{
      position:absolute; left:18px; top:18px; z-index:120;
      background: linear-gradient(180deg, var(--panel), rgba(0,0,0,0.12));
      padding:12px; border-radius:14px; backdrop-filter: blur(6px);
      box-shadow: 0 14px 40px rgba(0,0,0,0.6);
      color: #fff; min-width:220px;
    }
    #overlay h3{ margin:0 0 8px 0; font-size:15px; color: var(--accent-b) }
    #overlay p{ margin:0; font-size:13px; opacity:0.95 }
    .controls{ display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; align-items:center }
    .btn, .btn-ghost {
      position:relative; overflow:hidden;
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 14px; border-radius:14px; border:0; cursor:pointer; font-weight:700; font-size:14px;
      -webkit-tap-highlight-color: transparent; transition:transform .12s ease, box-shadow .12s ease;
    }
    .btn { background: linear-gradient(180deg, #9ff3ff, #ffc8e0); color:#111; box-shadow: 0 10px 30px rgba(170,190,240,0.08) }
    .btn:hover{ transform: translateY(-3px); box-shadow: 0 20px 40px rgba(170,190,240,0.12) }
    .btn-ghost{ background: transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; padding:9px 12px }
    .btn-ghost:hover{ background: rgba(255,255,255,0.02); transform: translateY(-2px) }
    .btn:focus{ outline:3px solid rgba(166,240,255,0.10); outline-offset:3px }
    .ripple{ position:absolute; border-radius:999px; transform:scale(0); animation:rip .6s ease-out; pointer-events:none; background:rgba(255,255,255,0.16) }
    @keyframes rip{ to{ transform:scale(2.6); opacity:0 } }
    #credits{ position:absolute; right:16px; bottom:18px; z-index:100; font-size:12px; color:#eedaef; padding:8px; border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.06)); }
    #hint{ position:absolute; left:50%; transform:translateX(-50%); bottom:20px; z-index:100; font-size:13px; padding:8px 14px; border-radius:999px; background: linear-gradient(90deg, rgba(166,240,255,0.04), rgba(255,179,200,0.03)); color:#ffdfe8 }
    #previewModal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.95)); z-index:250 }
    #previewContent{ max-width:94vw; max-height:92vh; padding:16px; border-radius:14px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); display:flex; flex-direction:column; gap:12px; box-shadow: 0 30px 90px rgba(0,0,0,0.8) }
    #previewContent img{ max-width:100%; max-height:82vh; border-radius:10px; display:block; box-shadow: 0 18px 50px rgba(0,0,0,0.6) }
    #previewClose{ align-self:flex-end; padding:8px 12px; border-radius:10px; border:0; background: linear-gradient(180deg,#9ff3ff,#ffc8e0); color:#111; cursor:pointer }
    #errorMessage{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:24px;text-align:center;color:#a6f0ff;text-shadow:0 0 10px #a6f0ff, 0 0 20px #a6f0ff;z-index:130;display:none}
    @media (max-width:900px){
      #overlay{ left:12px; top:12px; padding:10px; min-width:190px }
      .btn{ padding:9px 12px; font-size:14px }
    }
    @media (max-width:480px){
      #overlay{ left:8px; top:8px; padding:8px }
      .controls{ gap:8px }
      .btn{ padding:10px 12px; font-size:15px; border-radius:12px }
      #hint{ display:none }
    }
  </style>
</head>
<body>
  <div id="errorMessage">No creaste tu proyecto. Por favor, crea tu ID primero.</div>
  <div id="canvas-container"></div>
  <div id="overlay" role="region" aria-label="Controles">
    <h3>Puerta 2 — Sala Romántica (versión adaptada)</h3>
    <p>Mueve o toca para mirar. Pellizca para acercar/alejar en móvil.</p>
    <div class="controls">
      <button id="toggleAuto" class="btn" aria-pressed="false">Auto-rotar</button>
      <button id="styleBtn" class="btn-ghost">Toque visual</button>
      <button id="shuffleBtn" class="btn-ghost">Mezclar</button>
      <button id="returnBtn" class="btn-ghost">Regresar</button>
    </div>
  </div>
  <div id="credits">Imágenes desde Firebase • Interfaz al estilo romántico</div>
  <div id="hint">Toca una imagen para agrandarla</div>
  <div id="previewModal" aria-hidden="true">
    <div id="previewContent">
      <button id="previewClose">Cerrar</button>
      <img id="previewImage" src="" alt="Vista previa" />
    </div>
  </div>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js';
    import { getDatabase, ref, get } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBk2SVaP1w4V3MWrpp1r3X5Xk9eH06gBt4",
      authDomain: "tunel-de-recuerdos.firebaseapp.com",
      projectId: "tunel-de-recuerdos",
      storageBucket: "tunel-de-recuerdos.firebasestorage.app",
      messagingSenderId: "630660710506",
      appId: "1:630660710506:web:90d34150c9f21f668eca13",
      measurementId: "G-ETFDVEHML1"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);

    let imageUrls = [];
    async function fetchImages() {
      const errorMessage = document.getElementById('errorMessage');
      const urlParams = new URLSearchParams(window.location.search);
      const userId = urlParams.get('id')?.trim();
      console.log("ID extraído de la URL:", userId);

      if (!userId || userId === '') {
        console.error("No se encontró 'id' en la URL o es inválido.");
        errorMessage.textContent = 'No creaste tu proyecto. Por favor, crea tu ID primero.';
        errorMessage.style.display = 'block';
        return [];
      }

      try {
        console.log(`Consultando Firebase para usuarios/${userId}/puerta2Fotos`);
        const snapshot = await get(ref(database, `usuarios/${userId}`));
        if (snapshot.exists()) {
          const data = snapshot.val();
          const puertaFotos = data.puerta2Fotos || [];
          const validFotos = puertaFotos.slice(0, 5).filter(url => typeof url === 'string' && url.trim() !== '');
          console.log("Imágenes obtenidas de puerta2Fotos:", validFotos);
          if (validFotos.length === 0) {
            console.warn(`No hay imágenes en puerta2Fotos para el usuario ${userId}.`);
            errorMessage.textContent = 'No hay imágenes en tu galería. Agrega imágenes primero.';
            errorMessage.style.display = 'block';
          }
          return validFotos;
        } else {
          console.error(`No se encontraron datos para el usuario ${userId}.`);
          errorMessage.textContent = 'No creaste tu proyecto. Por favor, crea tu ID primero.';
          errorMessage.style.display = 'block';
          return [];
        }
      } catch (error) {
        console.error("Error al consultar Firebase:", error);
        errorMessage.textContent = 'Error al cargar las imágenes. Por favor, intenta de nuevo.';
        errorMessage.style.display = 'block';
        return [];
      }
    }

    (async function(){
      imageUrls = await fetchImages();
      console.log("Imágenes finales para la escena:", imageUrls);

      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 720;
      const TOTAL_IMAGES = isMobile ? 10 : 20;
      const FRAME_W = isMobile ? 220 : 340;
      const FRAME_H = isMobile ? 150 : 220;
      let cameraDistance = isMobile ? 950 : 820;

      const container = document.getElementById('canvas-container');
      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1.5, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.display = 'block';
      renderer.domElement.style.touchAction = 'none';
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x040007);
      scene.fog = new THREE.FogExp2(0x040007, 0.00018);

      const camera = new THREE.PerspectiveCamera(68, window.innerWidth/window.innerHeight, 0.1, 12000);
      camera.position.set(0, 60, cameraDistance);

      const hemi = new THREE.HemisphereLight(0xfff8fb, 0x0b0b14, 0.55); scene.add(hemi);
      const ambient = new THREE.AmbientLight(0xffeaf4, 0.18); scene.add(ambient);
      const point = new THREE.PointLight(0xffc8e8, 0.9, 2000); point.position.set(700, 300, 300); scene.add(point);

      const roomSize = 2600;
      const floorMat = new THREE.MeshStandardMaterial({ color:0x06050a, roughness:0.18, metalness:0.12 });
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), floorMat);
      floor.rotation.x = -Math.PI/2; floor.position.y = -420; scene.add(floor);
      const ring = new THREE.Mesh(new THREE.TorusGeometry(920, 16, 48, 300), new THREE.MeshStandardMaterial({ color:0xa6f0ff, emissive:0xffc2dd, emissiveIntensity:0.12, roughness:0.5, metalness:0.3 }));
      ring.rotation.x = Math.PI/2; ring.position.y = -80; scene.add(ring);

      const starsCount = isMobile ? 300 : 700;
      const starsGeo = new THREE.BufferGeometry(), starsPos = new Float32Array(starsCount*3);
      for(let i=0;i<starsCount;i++){
        const r = 400 + Math.random()*2000;
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(2*Math.random()-1);
        starsPos[i*3]   = Math.sin(phi)*Math.cos(theta)*r;
        starsPos[i*3+1] = Math.sin(phi)*Math.sin(theta)*r*0.55;
        starsPos[i*3+2] = Math.cos(phi)*r;
      }
      starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos,3));
      const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({ size: isMobile ? 2.0 : 3.2, color: 0xffffff, opacity:0.95, transparent:true }));
      scene.add(stars);

      const imagesGroup = new THREE.Group(); scene.add(imagesGroup);
      const loader = new THREE.TextureLoader(); loader.setCrossOrigin('');

      function heartPoint(t, scale=1){
        const x = 16*Math.pow(Math.sin(t),3);
        const y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
        return new THREE.Vector3(x*scale, y*scale, Math.sin(t*3.1)*40*scale);
      }

      function createFramedImage(url, pos, idx){
        const glow = new THREE.Mesh(new THREE.PlaneGeometry(FRAME_W*1.14, FRAME_H*1.14), new THREE.MeshBasicMaterial({ color:0xa6f0ff, transparent:true, opacity:0.08, side:THREE.DoubleSide }));
        const frame = new THREE.Mesh(new THREE.BoxGeometry(FRAME_W*1.04, FRAME_H*1.06, 10), new THREE.MeshStandardMaterial({ color:0x2b1b1f, roughness:0.2, metalness:0.6 }));
        const imgMat = new THREE.MeshBasicMaterial({ color:0xffffff });
        const imgPlane = new THREE.Mesh(new THREE.PlaneGeometry(FRAME_W-14, FRAME_H-14), imgMat);
        const group = new THREE.Group();
        glow.position.set(0, 8, -6);
        frame.position.set(0,0,-8);
        imgPlane.position.set(0,0,6);
        group.add(glow, frame, imgPlane);
        group.position.copy(pos);
        group.userData = { url, idx };
        loader.load(url, (tex)=>{ imgMat.map = tex; imgMat.needsUpdate = true; });
        group.scale.set(1,1,1);
        imagesGroup.add(group);
        return group;
      }

      let layoutMode = 'heart';
      function arrangeImages(mode='heart'){
        while(imagesGroup.children.length) imagesGroup.remove(imagesGroup.children[0]);
        const total = TOTAL_IMAGES;
        const placed = [];
        for(let i=0;i<total;i++){
          const t = (i/total) * Math.PI*2;
          let pos;
          if(mode === 'heart'){
            const base = heartPoint(t, 30);
            const layer = 1 + Math.floor(i / Math.max(1, Math.floor(total/6))) * 0.14;
            pos = new THREE.Vector3(base.x*layer, base.y*layer - 120, base.z*layer);
            pos.x += (Math.random()-0.5)*28;
            pos.z += (Math.random()-0.5)*28;
          } else {
            const radius = 420 + i*18;
            const ang = i * 0.38;
            pos = new THREE.Vector3(Math.cos(ang)*radius + (Math.random()-0.5)*40, -30 + Math.sin(i*0.36)*14, Math.sin(ang)*radius + (Math.random()-0.5)*40);
          }
          let attempts = 0;
          while(placed.some(p => p.distanceTo(pos) < 160) && attempts < 40){
            pos.x += (Math.random()-0.5) * 36;
            pos.z += (Math.random()-0.5) * 36;
            attempts++;
          }
          placed.push(pos.clone());
          pos.y = Math.max(-300, Math.min(160, pos.y));
          const url = imageUrls[i % imageUrls.length];
          createFramedImage(url, pos, i);
        }
      }
      arrangeImages(layoutMode);

      const petalsCount = isMobile ? 60 : 120;
      const petalsGeo = new THREE.BufferGeometry();
      const petPos = new Float32Array(petalsCount*3);
      for(let i=0;i<petalsCount;i++){
        petPos[i*3] = (Math.random()-0.5)*2200;
        petPos[i*3+1] = -200 + Math.random()*900;
        petPos[i*3+2] = (Math.random()-0.5)*2200;
      }
      petalsGeo.setAttribute('position', new THREE.BufferAttribute(petPos,3));
      function createHeartTexture(){
        const s = 128;
        const c = document.createElement('canvas'); c.width = s; c.height = s;
        const cx = c.getContext('2d');
        cx.clearRect(0,0,s,s);
        cx.fillStyle = 'rgba(255,155,190,0.98)';
        cx.beginPath();
        const x = s/2, y=s/2, sc=s/26;
        cx.moveTo(x, y+3*sc);
        cx.bezierCurveTo(x+11*sc, y-9*sc, x+20*sc, y+9*sc, x, y+18*sc);
        cx.bezierCurveTo(x-20*sc, y+9*sc, x-11*sc, y-9*sc, x, y+3*sc);
        cx.closePath();
        cx.fill();
        cx.globalCompositeOperation = 'lighter';
        cx.fillStyle = 'rgba(255,210,230,0.18)';
        cx.beginPath(); cx.arc(x, y+2*sc, 30*sc, 0, Math.PI*2); cx.fill();
        return new THREE.CanvasTexture(c);
      }
      const heartTex = createHeartTexture();
      const petalsMat = new THREE.PointsMaterial({ size: 46, map: heartTex, transparent:true, alphaTest:0.01, depthWrite:false });
      const petals = new THREE.Points(petalsGeo, petalsMat);
      scene.add(petals);

      const lanterns = new THREE.Group(), orbs = new THREE.Group();
      scene.add(lanterns); scene.add(orbs);
      function addLantern(pos, color=0xffd0e6){
        const geo = new THREE.SphereGeometry(18, 12, 12);
        const mat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity:0.84, roughness:0.4, metalness:0.05 });
        const m = new THREE.Mesh(geo, mat); m.position.copy(pos);
        const light = new THREE.PointLight(color, 0.7, 600);
        light.position.copy(pos);
        lanterns.add(m); lanterns.add(light);
      }
      for(let i=0;i<12;i++){ const a = i/12*Math.PI*2; const r=900; addLantern(new THREE.Vector3(Math.cos(a)*r, -120, Math.sin(a)*r)); }
      function addOrb(pos){ const geo = new THREE.SphereGeometry(28, 20, 20); const mat = new THREE.MeshPhysicalMaterial({ color:0xffffff, metalness:0.0, roughness:0.04, transmission:0.82, transparent:true, opacity:0.95, clearcoat:0.5 }); const m = new THREE.Mesh(geo, mat); m.position.copy(pos); orbs.add(m); }
      for(let i=0;i<8;i++){ const a=Math.random()*Math.PI*2; const r=400+Math.random()*900; addOrb(new THREE.Vector3(Math.cos(a)*r, -40 + Math.random()*200, Math.sin(a)*r)); }

      let mouse = new THREE.Vector2(0,0);
      const raycaster = new THREE.Raycaster();
      let hovered = null;
      let targetYaw = 0, targetPitch = 0;
      const maxPitch = Math.PI/2 - 0.08;
      let cameraYaw = 0, cameraPitch = 0;
      let isPointerDown = false, pointerStart = null;

      function getClientPoint(e){
        if(e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        if(e.changedTouches && e.changedTouches.length) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      }

      function onPointerMove(e){
        const p = getClientPoint(e);
        const rect = renderer.domElement.getBoundingClientRect();
        const mx = (p.x - rect.left)/rect.width;
        const my = (p.y - rect.top)/rect.height;
        if(e.pointerType === 'mouse' || (!e.touches && !e.pointerType)){
          targetYaw = -(mx - 0.5) * Math.PI * 1.05;
          targetPitch = -(my - 0.5) * Math.PI * 0.85;
          targetPitch = Math.max(-maxPitch, Math.min(maxPitch, targetPitch));
        } else {
          if(isPointerDown && pointerStart){
            const dx = (p.x - pointerStart.x) / window.innerWidth;
            const dy = (p.y - pointerStart.y) / window.innerHeight;
            targetYaw = -dx * Math.PI * 1.1;
            targetPitch = -dy * Math.PI * 0.9;
            targetPitch = Math.max(-maxPitch, Math.min(maxPitch, targetPitch));
          }
        }
      }

      renderer.domElement.addEventListener('pointermove', onPointerMove, { passive:true });
      renderer.domElement.addEventListener('pointerdown', (e)=>{ isPointerDown = true; pointerStart = getClientPoint(e); }, { passive:true });
      window.addEventListener('pointerup', ()=>{ isPointerDown = false; pointerStart = null; }, { passive:true });

      let pinchStartDist = 0, pinchStartCam = cameraDistance;
      renderer.domElement.addEventListener('touchstart', (e)=>{ if(e.touches && e.touches.length === 2){ pinchStartDist = getTouchDist(e); pinchStartCam = cameraDistance; } }, { passive:true });
      renderer.domElement.addEventListener('touchmove', (e)=>{ if(e.touches && e.touches.length ===2 && pinchStartDist>0){ const d = getTouchDist(e); const factor = pinchStartDist / d; cameraDistance = pinchStartCam * factor; cameraDistance = Math.max(300, Math.min(1800, cameraDistance)); } }, { passive:true });
      function getTouchDist(e){ if(!e.touches || e.touches.length<2) return 0; const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; return Math.sqrt(dx*dx + dy*dy); }

      renderer.domElement.addEventListener('wheel', (e)=>{ e.preventDefault(); cameraDistance += e.deltaY * 0.6; cameraDistance = Math.max(300, Math.min(1800, cameraDistance)); }, { passive:false });

      function onClick(e){
        const p = getClientPoint(e);
        const rect = renderer.domElement.getBoundingClientRect();
        const cx = p.x - rect.left;
        const cy = p.y - rect.top;
        const mx = (cx / rect.width)*2 - 1;
        const my = -((cy / rect.height)*2 - 1);
        raycaster.setFromCamera({ x: mx, y: my }, camera);
        const ints = raycaster.intersectObjects(imagesGroup.children, true);
        if(ints.length>0){
          let obj = ints[0].object;
          while(obj && (!obj.userData || !obj.userData.url)) obj = obj.parent;
          if(obj && obj.userData && obj.userData.url){
            openPreview(obj.userData.url);
            obj.scale.setScalar(1.06);
            setTimeout(()=> obj.scale.setScalar(1.0), 260);
          }
        }
        const btn = (e.target || e.srcElement).closest && (e.target || e.srcElement).closest('.btn, .btn-ghost');
        if(btn) createRipple(btn, p.x, p.y);
      }
      renderer.domElement.addEventListener('click', onClick, { passive:true });
      renderer.domElement.addEventListener('touchend', (e)=>{ if(e.changedTouches && e.changedTouches.length) onClick({ touches: e.touches, changedTouches: e.changedTouches }); }, { passive:true });

      const previewModal = document.getElementById('previewModal'), previewImage = document.getElementById('previewImage'), previewClose = document.getElementById('previewClose');
      function openPreview(url){ previewImage.src = url; previewModal.style.display = 'flex'; previewModal.setAttribute('aria-hidden','false'); }
      function closePreview(){ previewModal.style.display = 'none'; previewImage.src = ''; previewModal.setAttribute('aria-hidden','true'); }
      previewClose.addEventListener('click', closePreview);
      previewModal.addEventListener('click', (ev)=>{ if(ev.target === previewModal) closePreview(); });

      function createRipple(button, clientX, clientY){
        if(!button) return;
        const rect = button.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const r = Math.max(rect.width, rect.height);
        const el = document.createElement('span');
        el.className = 'ripple';
        el.style.width = el.style.height = (r*1.6) + 'px';
        el.style.left = (x - r*0.8) + 'px';
        el.style.top = (y - r*0.8) + 'px';
        button.appendChild(el);
        setTimeout(()=> el.remove(), 700);
      }

      const toggleBtn = document.getElementById('toggleAuto');
      let autoRotate = false;
      function toggleAuto(){ autoRotate = !autoRotate; toggleBtn.textContent = autoRotate ? 'Detener' : 'Auto-rotar'; toggleBtn.setAttribute('aria-pressed', String(autoRotate)); }
      toggleBtn.addEventListener('click', (e)=>{ createRipple(toggleBtn, e.clientX || (window.innerWidth/2), e.clientY || (window.innerHeight/2)); toggleAuto(); });

      const styleBtn = document.getElementById('styleBtn');
      styleBtn.addEventListener('click', (e)=>{ createRipple(styleBtn, e.clientX || (window.innerWidth/2), e.clientY || (window.innerHeight/2)); imagesGroup.children.forEach((g, i)=> g.rotation.y += (i%2 ? 0.18 : -0.18)); });

      const shuffleBtn = document.getElementById('shuffleBtn');
      shuffleBtn.addEventListener('click', (e)=>{ createRipple(shuffleBtn, e.clientX || (window.innerWidth/2), e.clientY || (window.innerHeight/2)); imagesGroup.children.forEach(g=>{ g.position.x += (Math.random()-0.5)*120; g.position.z += (Math.random()-0.5)*120; }); });

      const returnBtn = document.getElementById('returnBtn');
      returnBtn.addEventListener('click', (e)=>{
        createRipple(returnBtn, e.clientX || (window.innerWidth/2), e.clientY || (window.innerHeight/2));
        window.parent.postMessage({ type: 'doorClosed' }, '*');
      });

      let last = performance.now();
      function animate(){
        requestAnimationFrame(animate);
        const now = performance.now();
        const dt = Math.max(0.001, (now - last)/1000);
        last = now;

        const lerp = 1 - Math.pow(0.001, dt * 60);
        cameraYaw += (targetYaw - cameraYaw) * lerp;
        cameraPitch += (targetPitch - cameraPitch) * lerp;
        cameraPitch = Math.max(-maxPitch, Math.min(maxPitch, cameraPitch));
        if(autoRotate) cameraYaw -= dt * 0.02;

        const r = cameraDistance;
        const cx = Math.sin(cameraYaw) * r;
        const cz = Math.cos(cameraYaw) * r;
        const cy = -cameraPitch * 220 + 60;
        camera.position.set(cx, cy, cz);
        camera.lookAt(0,0,0);

        const posAttr = petals.geometry.getAttribute('position');
        for(let i=0;i<petalsCount;i++){
          let idx = i*3;
          posAttr.array[idx+1] += (1.2 + Math.sin(i*0.18 + now*0.001) * 0.55) * dt * 12;
          if(posAttr.array[idx+1] > 1200){
            posAttr.array[idx+1] = -200 - Math.random()*400;
            posAttr.array[idx] = (Math.random()-0.5)*2200;
            posAttr.array[idx+2] = (Math.random()-0.5)*2200;
          }
        }
        posAttr.needsUpdate = true;

        imagesGroup.children.forEach((g, idx)=>{ g.position.y += Math.sin(idx*0.6 + now*0.0008) * 0.0025; g.lookAt(camera.position); });

        lanterns.rotation && (lanterns.rotation.y += 0.0003);
        orbs.rotation && (orbs.rotation.y -= 0.00015);
        stars.rotation && (stars.rotation.y += 0.00012);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); arrangeImages(layoutMode); });

      window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') { closePreview(); } });

      window._puerta2rom = { arrangeImages, createFramedImage, imagesGroup };
    })();
  </script>
</body>
</html>
