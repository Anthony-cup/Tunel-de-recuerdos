<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puerta 2 — Sala Romántica (estética adaptada)</title>
  <style>
    :root{
      --accent-a:#a6f0ff;
      --accent-b:#ffb3d1;
      --panel: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;background:radial-gradient(1000px 700px at 15% 12%, rgba(170,220,255,0.02), transparent 8%), #040007;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#f7eef6}
    #canvas-container{width:100vw;height:100vh;position:relative;display:block;touch-action:none}
    /* Overlay (inspirado en el romántico) */
    #overlay{
      position:absolute; left:18px; top:18px; z-index:120;
      background: linear-gradient(180deg, var(--panel), rgba(0,0,0,0.12));
      padding:12px; border-radius:14px; backdrop-filter: blur(6px);
      box-shadow: 0 14px 40px rgba(0,0,0,0.6);
      color: #fff; min-width:220px;
    }
    #overlay h3{ margin:0 0 8px 0; font-size:15px; color: var(--accent-b) }
    #overlay p{ margin:0; font-size:13px; opacity:0.95 }
    .controls{ display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; align-items:center }

    /* Buttons (romántico, pero distinto) */
    .btn, .btn-ghost {
      position:relative; overflow:hidden;
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 14px; border-radius:14px; border:0; cursor:pointer; font-weight:700; font-size:14px;
      -webkit-tap-highlight-color: transparent; transition:transform .12s ease, box-shadow .12s ease;
    }
    .btn { background: linear-gradient(180deg, #9ff3ff, #ffc8e0); color:#111; box-shadow: 0 10px 30px rgba(170,190,240,0.08) }
    .btn:hover{ transform: translateY(-3px); box-shadow: 0 20px 40px rgba(170,190,240,0.12) }
    .btn-ghost{ background: transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; padding:9px 12px }
    .btn-ghost:hover{ background: rgba(255,255,255,0.02); transform: translateY(-2px) }
    .btn:focus{ outline:3px solid rgba(166,240,255,0.10); outline-offset:3px }

    /* ripple */
    .ripple{ position:absolute; border-radius:999px; transform:scale(0); animation:rip .6s ease-out; pointer-events:none; background:rgba(255,255,255,0.16) }
    @keyframes rip{ to{ transform:scale(2.6); opacity:0 } }

    /* small UI bits */
    #credits{ position:absolute; right:16px; bottom:18px; z-index:100; font-size:12px; color:#eedaef; padding:8px; border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.06)); }
    #hint{ position:absolute; left:50%; transform:translateX(-50%); bottom:20px; z-index:100; font-size:13px; padding:8px 14px; border-radius:999px; background: linear-gradient(90deg, rgba(166,240,255,0.04), rgba(255,179,200,0.03)); color:#ffdfe8 }
    #previewModal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.95)); z-index:250 }
    #previewContent{ max-width:94vw; max-height:92vh; padding:16px; border-radius:14px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); display:flex; flex-direction:column; gap:12px; box-shadow: 0 30px 90px rgba(0,0,0,0.8) }
    #previewContent img{ max-width:100%; max-height:82vh; border-radius:10px; display:block; box-shadow: 0 18px 50px rgba(0,0,0,0.6) }
    #previewClose{ align-self:flex-end; padding:8px 12px; border-radius:10px; border:0; background: linear-gradient(180deg,#9ff3ff,#ffc8e0); color:#111; cursor:pointer }

    /* responsive */
    @media (max-width:900px){
      #overlay{ left:12px; top:12px; padding:10px; min-width:190px }
      .btn{ padding:9px 12px; font-size:14px }
    }
    @media (max-width:480px){
      #overlay{ left:8px; top:8px; padding:8px }
      .controls{ gap:8px }
      .btn{ padding:10px 12px; font-size:15px; border-radius:12px }
      #hint{ display:none }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="overlay" role="region" aria-label="Controles">
    <h3>Puerta 2 — Sala Romántica (versión adaptada)</h3>
    <p>Mueve o toca para mirar. Pellizca para acercar/alejar en móvil.</p>
    <div class="controls">
      <button id="toggleAuto" class="btn" aria-pressed="false">Auto-rotar</button>
      <button id="styleBtn" class="btn-ghost">Toque visual</button>
      <button id="shuffleBtn" class="btn-ghost">Mezclar</button>
      <button id="returnBtn" class="btn-ghost">Regresar</button>
    </div>
  </div>

  <div id="credits">Imágenes de ejemplo: picsum.photos • Interfaz al estilo romántico</div>
  <div id="hint">Toca una imagen para agrandarla</div>

  <div id="previewModal" aria-hidden="true">
    <div id="previewContent">
      <button id="previewClose">Cerrar</button>
      <img id="previewImage" src="" alt="Vista previa" />
    </div>
  </div>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
  (function(){
    // --- Settings ---
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 720;
    const IMAGE_POOL = [
      'https://picsum.photos/id/1015/900/600','https://picsum.photos/id/1025/900/600','https://picsum.photos/id/1035/900/600',
      'https://picsum.photos/id/1041/900/600','https://picsum.photos/id/1050/900/600','https://picsum.photos/id/1069/900/600',
      'https://picsum.photos/id/1074/900/600','https://picsum.photos/id/1084/900/600'
    ];
    const TOTAL_IMAGES = isMobile ? 10 : 20;
    const FRAME_W = isMobile ? 220 : 340;
    const FRAME_H = isMobile ? 150 : 220;
    let cameraDistance = isMobile ? 950 : 820;

    // --- Renderer & Scene ---
    const container = document.getElementById('canvas-container');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1.5, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.display = 'block';
    renderer.domElement.style.touchAction = 'none';
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x040007);
    scene.fog = new THREE.FogExp2(0x040007, 0.00018);

    const camera = new THREE.PerspectiveCamera(68, window.innerWidth/window.innerHeight, 0.1, 12000);
    camera.position.set(0, 60, cameraDistance);

    // lighting
    const hemi = new THREE.HemisphereLight(0xfff8fb, 0x0b0b14, 0.55); scene.add(hemi);
    const ambient = new THREE.AmbientLight(0xffeaf4, 0.18); scene.add(ambient);
    const point = new THREE.PointLight(0xffc8e8, 0.9, 2000); point.position.set(700, 300, 300); scene.add(point);

    // floor + soft ring
    const roomSize = 2600;
    const floorMat = new THREE.MeshStandardMaterial({ color:0x06050a, roughness:0.18, metalness:0.12 });
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), floorMat);
    floor.rotation.x = -Math.PI/2; floor.position.y = -420; scene.add(floor);
    const ring = new THREE.Mesh(new THREE.TorusGeometry(920, 16, 48, 300), new THREE.MeshStandardMaterial({ color:0xa6f0ff, emissive:0xffc2dd, emissiveIntensity:0.12, roughness:0.5, metalness:0.3 }));
    ring.rotation.x = Math.PI/2; ring.position.y = -80; scene.add(ring);

    // stars / background dots
    const starsCount = isMobile ? 300 : 700;
    const starsGeo = new THREE.BufferGeometry(), starsPos = new Float32Array(starsCount*3);
    for(let i=0;i<starsCount;i++){
      const r = 400 + Math.random()*2000;
      const theta = Math.random()*Math.PI*2;
      const phi = Math.acos(2*Math.random()-1);
      starsPos[i*3]   = Math.sin(phi)*Math.cos(theta)*r;
      starsPos[i*3+1] = Math.sin(phi)*Math.sin(theta)*r*0.55;
      starsPos[i*3+2] = Math.cos(phi)*r;
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos,3));
    const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({ size: isMobile ? 2.0 : 3.2, color: 0xffffff, opacity:0.95, transparent:true }));
    scene.add(stars);

    // group for images
    const imagesGroup = new THREE.Group(); scene.add(imagesGroup);
    const loader = new THREE.TextureLoader(); loader.setCrossOrigin('');

    // heart param func (used for shape variety)
    function heartPoint(t, scale=1){
      const x = 16*Math.pow(Math.sin(t),3);
      const y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
      return new THREE.Vector3(x*scale, y*scale, Math.sin(t*3.1)*40*scale);
    }

    // create framed image (glow + frame + image plane)
    function createFramedImage(url, pos, idx){
      const glow = new THREE.Mesh(new THREE.PlaneGeometry(FRAME_W*1.14, FRAME_H*1.14), new THREE.MeshBasicMaterial({ color:0xa6f0ff, transparent:true, opacity:0.08, side:THREE.DoubleSide }));
      const frame = new THREE.Mesh(new THREE.BoxGeometry(FRAME_W*1.04, FRAME_H*1.06, 10), new THREE.MeshStandardMaterial({ color:0x2b1b1f, roughness:0.2, metalness:0.6 }));
      const imgMat = new THREE.MeshBasicMaterial({ color:0xffffff });
      const imgPlane = new THREE.Mesh(new THREE.PlaneGeometry(FRAME_W-14, FRAME_H-14), imgMat);

      const group = new THREE.Group();
      glow.position.set(0, 8, -6);
      frame.position.set(0,0,-8);
      imgPlane.position.set(0,0,6);
      group.add(glow, frame, imgPlane);
      group.position.copy(pos);
      group.userData = { url, idx };
      loader.load(url, (tex)=>{ imgMat.map = tex; imgMat.needsUpdate = true; });

      // subtle hover scale property
      group.scale.set(1,1,1);
      imagesGroup.add(group);
      return group;
    }

    // arrange images with two possible styles (heart-like or spiral)
    let layoutMode = 'heart'; // 'heart' or 'spiral'
    function arrangeImages(mode='heart'){
      while(imagesGroup.children.length) imagesGroup.remove(imagesGroup.children[0]);
      const total = TOTAL_IMAGES;
      const placed = [];
      for(let i=0;i<total;i++){
        const t = (i/total) * Math.PI*2;
        let pos;
        if(mode === 'heart'){
          const base = heartPoint(t, 30);
          const layer = 1 + Math.floor(i / Math.max(1, Math.floor(total/6))) * 0.14;
          pos = new THREE.Vector3(base.x*layer, base.y*layer - 120, base.z*layer);
          pos.x += (Math.random()-0.5)*28;
          pos.z += (Math.random()-0.5)*28;
        } else {
          const radius = 420 + i*18;
          const ang = i * 0.38;
          pos = new THREE.Vector3(Math.cos(ang)*radius + (Math.random()-0.5)*40, -30 + Math.sin(i*0.36)*14, Math.sin(ang)*radius + (Math.random()-0.5)*40);
        }

        // mild collision avoidance
        let attempts = 0;
        while(placed.some(p => p.distanceTo(pos) < 160) && attempts < 40){
          pos.x += (Math.random()-0.5) * 36;
          pos.z += (Math.random()-0.5) * 36;
          attempts++;
        }
        placed.push(pos.clone());
        pos.y = Math.max(-300, Math.min(160, pos.y));
        const url = IMAGE_POOL[i % IMAGE_POOL.length];
        createFramedImage(url, pos, i);
      }
    }
    arrangeImages(layoutMode);

    // petals as Points
    const petalsCount = isMobile ? 60 : 120;
    const petalsGeo = new THREE.BufferGeometry();
    const petPos = new Float32Array(petalsCount*3);
    for(let i=0;i<petalsCount;i++){
      petPos[i*3] = (Math.random()-0.5)*2200;
      petPos[i*3+1] = -200 + Math.random()*900;
      petPos[i*3+2] = (Math.random()-0.5)*2200;
    }
    petalsGeo.setAttribute('position', new THREE.BufferAttribute(petPos,3));
    // simple heart canvas texture for petals
    function createHeartTexture(){
      const s = 128;
      const c = document.createElement('canvas'); c.width = s; c.height = s;
      const cx = c.getContext('2d');
      cx.clearRect(0,0,s,s);
      cx.fillStyle = 'rgba(255,155,190,0.98)';
      cx.beginPath();
      const x = s/2, y=s/2, sc=s/26;
      cx.moveTo(x, y+3*sc);
      cx.bezierCurveTo(x+11*sc, y-9*sc, x+20*sc, y+9*sc, x, y+18*sc);
      cx.bezierCurveTo(x-20*sc, y+9*sc, x-11*sc, y-9*sc, x, y+3*sc);
      cx.closePath();
      cx.fill();
      cx.globalCompositeOperation = 'lighter';
      cx.fillStyle = 'rgba(255,210,230,0.18)';
      cx.beginPath(); cx.arc(x, y+2*sc, 30*sc, 0, Math.PI*2); cx.fill();
      return new THREE.CanvasTexture(c);
    }
    const heartTex = createHeartTexture();
    const petalsMat = new THREE.PointsMaterial({ size: 46, map: heartTex, transparent:true, alphaTest:0.01, depthWrite:false });
    const petals = new THREE.Points(petalsGeo, petalsMat);
    scene.add(petals);

    // lanterns and orbs
    const lanterns = new THREE.Group(), orbs = new THREE.Group();
    scene.add(lanterns); scene.add(orbs);
    function addLantern(pos, color=0xffd0e6){
      const geo = new THREE.SphereGeometry(18, 12, 12);
      const mat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity:0.84, roughness:0.4, metalness:0.05 });
      const m = new THREE.Mesh(geo, mat); m.position.copy(pos);
      const light = new THREE.PointLight(color, 0.7, 600);
      light.position.copy(pos);
      lanterns.add(m); lanterns.add(light);
    }
    for(let i=0;i<12;i++){ const a = i/12*Math.PI*2; const r=900; addLantern(new THREE.Vector3(Math.cos(a)*r, -120, Math.sin(a)*r)); }
    function addOrb(pos){ const geo = new THREE.SphereGeometry(28, 20, 20); const mat = new THREE.MeshPhysicalMaterial({ color:0xffffff, metalness:0.0, roughness:0.04, transmission:0.82, transparent:true, opacity:0.95, clearcoat:0.5 }); const m = new THREE.Mesh(geo, mat); m.position.copy(pos); orbs.add(m); }
    for(let i=0;i<8;i++){ const a=Math.random()*Math.PI*2; const r=400+Math.random()*900; addOrb(new THREE.Vector3(Math.cos(a)*r, -40 + Math.random()*200, Math.sin(a)*r)); }

    // --- Interaction: camera control (desktop: move to look; mobile: touch drag; pinch zoom) ---
    let mouse = new THREE.Vector2(0,0);
    const raycaster = new THREE.Raycaster();
    let hovered = null;
    let targetYaw = 0, targetPitch = 0;
    const maxPitch = Math.PI/2 - 0.08;
    let cameraYaw = 0, cameraPitch = 0;
    let isPointerDown = false, pointerStart = null;

    // get pointer coords helper
    function getClientPoint(e){
      if(e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      if(e.changedTouches && e.changedTouches.length) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
      return { x: e.clientX, y: e.clientY };
    }

    function onPointerMove(e){
      const p = getClientPoint(e);
      const rect = renderer.domElement.getBoundingClientRect();
      const mx = (p.x - rect.left)/rect.width;
      const my = (p.y - rect.top)/rect.height;
      // desktop: move without press
      if(e.pointerType === 'mouse' || (!e.touches && !e.pointerType)){
        targetYaw = -(mx - 0.5) * Math.PI * 1.05;
        targetPitch = -(my - 0.5) * Math.PI * 0.85;
        targetPitch = Math.max(-maxPitch, Math.min(maxPitch, targetPitch));
      } else {
        // touch drag: if dragging compute relative
        if(isPointerDown && pointerStart){
          const dx = (p.x - pointerStart.x) / window.innerWidth;
          const dy = (p.y - pointerStart.y) / window.innerHeight;
          targetYaw = -dx * Math.PI * 1.1;
          targetPitch = -dy * Math.PI * 0.9;
          targetPitch = Math.max(-maxPitch, Math.min(maxPitch, targetPitch));
        }
      }
    }

    renderer.domElement.addEventListener('pointermove', onPointerMove, { passive:true });
    renderer.domElement.addEventListener('pointerdown', (e)=>{ isPointerDown = true; pointerStart = getClientPoint(e); }, { passive:true });
    window.addEventListener('pointerup', ()=>{ isPointerDown = false; pointerStart = null; }, { passive:true });

    // pinch zoom
    let pinchStartDist = 0, pinchStartCam = cameraDistance;
    renderer.domElement.addEventListener('touchstart', (e)=>{ if(e.touches && e.touches.length === 2){ pinchStartDist = getTouchDist(e); pinchStartCam = cameraDistance; } }, { passive:true });
    renderer.domElement.addEventListener('touchmove', (e)=>{ if(e.touches && e.touches.length ===2 && pinchStartDist>0){ const d = getTouchDist(e); const factor = pinchStartDist / d; cameraDistance = pinchStartCam * factor; cameraDistance = Math.max(300, Math.min(1800, cameraDistance)); } }, { passive:true });
    function getTouchDist(e){ if(!e.touches || e.touches.length<2) return 0; const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; return Math.sqrt(dx*dx + dy*dy); }

    // wheel zoom
    renderer.domElement.addEventListener('wheel', (e)=>{ e.preventDefault(); cameraDistance += e.deltaY * 0.6; cameraDistance = Math.max(300, Math.min(1800, cameraDistance)); }, { passive:false });

    // click/tap to open preview & ripple
    function onClick(e){
      const p = getClientPoint(e);
      const rect = renderer.domElement.getBoundingClientRect();
      const cx = p.x - rect.left;
      const cy = p.y - rect.top;
      const mx = (cx / rect.width)*2 - 1;
      const my = -((cy / rect.height)*2 - 1);
      raycaster.setFromCamera({ x: mx, y: my }, camera);
      const ints = raycaster.intersectObjects(imagesGroup.children, true);
      if(ints.length>0){
        let obj = ints[0].object;
        while(obj && (!obj.userData || !obj.userData.url)) obj = obj.parent;
        if(obj && obj.userData && obj.userData.url){
          openPreview(obj.userData.url);
          // small visual burst: scale briefly
          obj.scale.setScalar(1.06);
          setTimeout(()=> obj.scale.setScalar(1.0), 260);
        }
      }
      // ripple for buttons
      const btn = (e.target || e.srcElement).closest && (e.target || e.srcElement).closest('.btn, .btn-ghost');
      if(btn) createRipple(btn, p.x, p.y);
    }
    renderer.domElement.addEventListener('click', onClick, { passive:true });
    renderer.domElement.addEventListener('touchend', (e)=>{ if(e.changedTouches && e.changedTouches.length) onClick({ touches: e.touches, changedTouches: e.changedTouches }); }, { passive:true });

    // preview modal
    const previewModal = document.getElementById('previewModal'), previewImage = document.getElementById('previewImage'), previewClose = document.getElementById('previewClose');
    function openPreview(url){ previewImage.src = url; previewModal.style.display = 'flex'; previewModal.setAttribute('aria-hidden','false'); }
    function closePreview(){ previewModal.style.display = 'none'; previewImage.src = ''; previewModal.setAttribute('aria-hidden','true'); }
    previewClose.addEventListener('click', closePreview);
    previewModal.addEventListener('click', (ev)=>{ if(ev.target === previewModal) closePreview(); });

    // ripple creation
    function createRipple(button, clientX, clientY){
      if(!button) return;
      const rect = button.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const r = Math.max(rect.width, rect.height);
      const el = document.createElement('span');
      el.className = 'ripple';
      el.style.width = el.style.height = (r*1.6) + 'px';
      el.style.left = (x - r*0.8) + 'px';
      el.style.top = (y - r*0.8) + 'px';
      button.appendChild(el);
      setTimeout(()=> el.remove(), 700);
    }

    // buttons: Auto-rotate, style, shuffle, return
    const toggleBtn = document.getElementById('toggleAuto');
    let autoRotate = false;
    function toggleAuto(){ autoRotate = !autoRotate; toggleBtn.textContent = autoRotate ? 'Detener' : 'Auto-rotar'; toggleBtn.setAttribute('aria-pressed', String(autoRotate)); }
    toggleBtn.addEventListener('click', (e)=>{ createRipple(toggleBtn, e.clientX || (window.innerWidth/2), e.clientY || (window.innerHeight/2)); toggleAuto(); });

    const styleBtn = document.getElementById('styleBtn');
    styleBtn.addEventListener('click', (e)=>{ createRipple(styleBtn, e.clientX || (window.innerWidth/2), e.clientY || (window.innerHeight/2)); // small style toggle
      imagesGroup.children.forEach((g, i)=> g.rotation.y += (i%2 ? 0.18 : -0.18));
    });

    const shuffleBtn = document.getElementById('shuffleBtn');
    shuffleBtn.addEventListener('click', (e)=>{ createRipple(shuffleBtn, e.clientX || (window.innerWidth/2), e.clientY || (window.innerHeight/2)); imagesGroup.children.forEach(g=>{ g.position.x += (Math.random()-0.5)*120; g.position.z += (Math.random()-0.5)*120; }); });

    // --- RETURN BUTTON: keep EXACT behavior requested ---
    const returnBtn = document.getElementById('returnBtn');
    returnBtn.addEventListener('click', (e)=>{
      createRipple(returnBtn, e.clientX || (window.innerWidth/2), e.clientY || (window.innerHeight/2));
      // send exactly the same message as you had before:
      window.parent.postMessage({ type: 'doorClosed' }, '*');
    });

    // animate loop
    let last = performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.max(0.001, (now - last)/1000);
      last = now;

      // camera interpolation
      const lerp = 1 - Math.pow(0.001, dt * 60);
      cameraYaw += (targetYaw - cameraYaw) * lerp;
      cameraPitch += (targetPitch - cameraPitch) * lerp;
      cameraPitch = Math.max(-maxPitch, Math.min(maxPitch, cameraPitch));
      if(autoRotate) cameraYaw -= dt * 0.02;

      // spherical camera around center
      const r = cameraDistance;
      const cx = Math.sin(cameraYaw) * r;
      const cz = Math.cos(cameraYaw) * r;
      const cy = -cameraPitch * 220 + 60;
      camera.position.set(cx, cy, cz);
      camera.lookAt(0,0,0);

      // animate petals
      const posAttr = petals.geometry.getAttribute('position');
      for(let i=0;i<petalsCount;i++){
        let idx = i*3;
        posAttr.array[idx+1] += (1.2 + Math.sin(i*0.18 + now*0.001) * 0.55) * dt * 12;
        if(posAttr.array[idx+1] > 1200){
          posAttr.array[idx+1] = -200 - Math.random()*400;
          posAttr.array[idx] = (Math.random()-0.5)*2200;
          posAttr.array[idx+2] = (Math.random()-0.5)*2200;
        }
      }
      posAttr.needsUpdate = true;

      // gentle motion of images + face camera
      imagesGroup.children.forEach((g, idx)=>{ g.position.y += Math.sin(idx*0.6 + now*0.0008) * 0.0025; g.lookAt(camera.position); });

      // orbiting lights
      lanterns.rotation && (lanterns.rotation.y += 0.0003);
      orbs.rotation && (orbs.rotation.y -= 0.00015);
      stars.rotation && (stars.rotation.y += 0.00012);

      renderer.render(scene, camera);
    }
    animate();

    // resize handler
    window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); arrangeImages(layoutMode); });

    // keyboard: close preview on Esc
    window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') { closePreview(); } });

    // expose some helpers for debugging
    window._puerta2rom = { arrangeImages, createFramedImage, imagesGroup };

  })();
  </script>
</body>
</html>
