<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puerta Romántica — Formas nuevas</title>
  <style>
    :root{
      --accentA:#ffd8ea;
      --accentB:#ff7dbb;
      --panel: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;background:
      radial-gradient(900px 600px at 25% 12%, rgba(255,120,180,0.03), transparent 8%),
      linear-gradient(180deg,#170016,#050006);overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#fff}
    #canvas-container{width:100vw;height:100vh;position:relative;display:block;touch-action:none}
    #overlay{position:absolute;left:14px;top:14px;z-index:300;padding:12px;border-radius:12px;background:linear-gradient(180deg,var(--panel), rgba(0,0,0,0.12));backdrop-filter:blur(6px);min-width:230px}
    #overlay h3{margin:0 0 8px 0;color:var(--accentA);font-size:15px}
    #overlay p{margin:0;font-size:13px;opacity:0.95}
    .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
    .btn, .btn-ghost{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;border:0;cursor:pointer;font-weight:700;font-size:14px;transition:transform .12s}
    .btn{background:linear-gradient(180deg,var(--accentA),var(--accentB));color:#111}
    .btn:hover{transform:translateY(-3px)}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff}
    #credits{position:absolute;right:14px;bottom:14px;color:#ffdfe8;font-size:12px;z-index:250;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(0,0,0,0.06))}
    #hint{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;color:#ffdfe8;z-index:250;font-size:13px;padding:8px 14px;border-radius:999px;background:linear-gradient(90deg, rgba(255,130,190,0.04), rgba(255,220,190,0.03));backdrop-filter:blur(2px)}
    #previewModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.95));z-index:600}
    #previewContent{max-width:94vw;max-height:92vh;padding:14px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;flex-direction:column;gap:10px}
    #previewContent img{max-width:100%;max-height:82vh;border-radius:10px;display:block}
    #previewClose{align-self:flex-end;padding:8px 12px;border-radius:10px;border:0;background:linear-gradient(180deg,var(--accentA),var(--accentB));color:#111;cursor:pointer}
    #errorMessage{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:24px;text-align:center;color:#ffd8ea;text-shadow:0 0 10px #ffd8ea, 0 0 20px #ffd8ea;z-index:130;display:none}
    @media (max-width:720px){ #overlay{left:10px;top:10px;padding:10px} .btn{padding:8px 10px} #hint{display:none} }
  </style>
</head>
<body>
  <div id="errorMessage">No creaste tu proyecto. Por favor, crea tu ID primero.</div>
  <div id="canvas-container" aria-hidden="false"></div>

  <div id="overlay" role="region" aria-label="Controles">
    <h3></h3>
    <p></p>
    <div class="controls">
      <button id="toggleAuto" class="btn" aria-pressed="false">Auto-rotar</button>
      <button id="nextShape" class="btn-ghost">Siguiente forma</button>
      <button id="returnBtn" class="btn-ghost">Regresar</button>
    </div>
  </div>

  <div id="credits">Imágenes desde Firebase • Interfaz romántica</div>
  <div id="hint">Pulsa una imagen para ampliar</div>

  <div id="previewModal" aria-hidden="true">
    <div id="previewContent"><button id="previewClose">Cerrar</button><img id="previewImage" src="" alt="Vista previa"></div>
  </div>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js';
    import { getDatabase, ref, get } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js';
    const firebaseConfig = {
      apiKey: "AIzaSyBk2SVaP1w4V3MWrpp1r3X5Xk9eH06gBt4",
      authDomain: "tunel-de-recuerdos.firebaseapp.com",
      projectId: "tunel-de-recuerdos",
      storageBucket: "tunel-de-recuerdos.firebasestorage.app",
      messagingSenderId: "630660710506",
      appId: "1:630660710506:web:90d34150c9f21f668eca13",
      measurementId: "G-ETFDVEHML1"
    };
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    let imageUrls = [];
    async function fetchImages() {
      const errorMessage = document.getElementById('errorMessage');
      const urlParams = new URLSearchParams(window.location.search);
      const userId = urlParams.get('id')?.trim();
      console.log("ID extraído de la URL:", userId);
      if (!userId || userId === '') {
        console.error("No se encontró 'id' en la URL o es inválido.");
        errorMessage.textContent = 'No creaste tu proyecto. Por favor, crea tu ID primero.';
        errorMessage.style.display = 'block';
        return [];
      }
      try {
        console.log(`Consultando Firebase para usuarios/${userId}/puerta5Fotos`);
        const snapshot = await get(ref(database, `usuarios/${userId}`));
        if (snapshot.exists()) {
          const data = snapshot.val();
          const puertaFotos = data.puerta5Fotos || [];
          const validFotos = puertaFotos.slice(0, 5).filter(url => typeof url === 'string' && url.trim() !== '');
          console.log("Imágenes obtenidas de puerta5Fotos:", validFotos);
          if (validFotos.length === 0) {
            console.warn(`No hay imágenes en puerta5Fotos para el usuario ${userId}.`);
            errorMessage.textContent = 'No hay imágenes en tu galería. Agrega imágenes primero.';
            errorMessage.style.display = 'block';
          }
          return validFotos;
        } else {
          console.error(`No se encontraron datos para el usuario ${userId}.`);
          errorMessage.textContent = 'No creaste tu proyecto. Por favor, crea tu ID primero.';
          errorMessage.style.display = 'block';
          return [];
        }
      } catch (error) {
        console.error("Error al consultar Firebase:", error);
        errorMessage.textContent = 'Error al cargar las imágenes. Por favor, intenta de nuevo.';
        errorMessage.style.display = 'block';
        return [];
      }
    }
    (async function(){
      imageUrls = await fetchImages();
      console.log("Imágenes finales para la escena:", imageUrls);
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 720;
      const TOTAL_IMAGES = 10;
      const PARTICLES = isMobile ? 300 : 700;
      const FRAME_W = isMobile ? 220 : 320;
      const FRAME_H = isMobile ? 150 : 210;

      const container = document.getElementById('canvas-container');
      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1.5, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.display='block';
      renderer.domElement.style.touchAction='none';
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0410);
      scene.fog = new THREE.FogExp2(0x0a0410, 0.00014);

      const camera = new THREE.PerspectiveCamera(66, window.innerWidth/window.innerHeight, 0.1, 12000);
      let cameraRadius = isMobile ? 980 : 760;
      camera.position.set(0, 40, cameraRadius);

      scene.add(new THREE.HemisphereLight(0xffeef8, 0x050016, 0.6));
      scene.add(new THREE.AmbientLight(0xffeaf4, 0.18));
      const key = new THREE.PointLight(0xff9ecf, 0.9, 2500); key.position.set(700,260,300); scene.add(key);

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(2600,2600), new THREE.MeshStandardMaterial({ color:0x04030a, roughness:0.18 }));
      floor.rotation.x = -Math.PI/2; floor.position.y = -420; scene.add(floor);
      const ring = new THREE.Mesh(new THREE.TorusGeometry(880, 12, 36, 260), new THREE.MeshStandardMaterial({ color:0xffc2e6, emissive:0xffc2e6, emissiveIntensity:0.06, roughness:0.45 }));
      ring.rotation.x = Math.PI/2; ring.position.y = -86; scene.add(ring);

      const imagesGroup = new THREE.Group(); scene.add(imagesGroup);
      const loader = new THREE.TextureLoader(); loader.setCrossOrigin('');

      function createFrame(url, pos, idx){
        const glow = new THREE.Mesh(new THREE.PlaneGeometry(FRAME_W*1.12, FRAME_H*1.12), new THREE.MeshBasicMaterial({ color:0xffcfe6, transparent:true, opacity:0.08, side:THREE.DoubleSide }));
        const frame = new THREE.Mesh(new THREE.BoxGeometry(FRAME_W*1.03, FRAME_H*1.04, 12), new THREE.MeshStandardMaterial({ color:0x1d1419, roughness:0.18, metalness:0.6 }));
        const imgMat = new THREE.MeshBasicMaterial({ color:0xffffff });
        const img = new THREE.Mesh(new THREE.PlaneGeometry(FRAME_W-14, FRAME_H-14), imgMat);
        const g = new THREE.Group();
        glow.position.set(0,8,-6); frame.position.set(0,0,-8); img.position.set(0,0,6);
        g.add(glow, frame, img);
        g.position.copy(pos);
        g.userData = { url, idx };
        loader.load(url, tex => { imgMat.map = tex; imgMat.needsUpdate = true; });
        imagesGroup.add(g);
        return g;
      }

      function arrangeImagesCircular(){
        while(imagesGroup.children.length) imagesGroup.remove(imagesGroup.children[0]);
        const total = TOTAL_IMAGES;
        const radius = 420;
        for(let i=0;i<total;i++){
          const a = (i/total) * Math.PI * 2;
          const layer = (i%2===0)? 0 : 1;
          const rad = radius + layer*86 + (Math.random()-0.5)*32;
          const x = Math.cos(a)*rad + (Math.random()-0.5)*26;
          const z = Math.sin(a)*rad + (Math.random()-0.5)*26;
          const y = -120 + Math.sin(i*0.7)*28 + (layer*26);
          createFrame(imageUrls[i % imageUrls.length], new THREE.Vector3(x,y,z), i);
        }
      }
      arrangeImagesCircular();

      const starsCount = isMobile ? 300 : 700;
      const starsGeo = new THREE.BufferGeometry();
      const starsPos = new Float32Array(starsCount*3);
      for(let i=0;i<starsCount;i++){
        const r = 400 + Math.random()*2000;
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(2*Math.random()-1);
        starsPos[i*3] = Math.sin(phi)*Math.cos(theta)*r;
        starsPos[i*3+1] = Math.sin(phi)*Math.sin(theta)*r*0.55;
        starsPos[i*3+2] = Math.cos(phi)*r;
      }
      starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos,3));
      const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({ size:isMobile?2.0:3.0, color:0xffffff, opacity:0.9, transparent:true }));
      scene.add(stars);

      const ptsGeo = new THREE.BufferGeometry();
      const posArr = new Float32Array(PARTICLES*3);
      const sizes = new Float32Array(PARTICLES);
      for(let i=0;i<PARTICLES;i++){
        posArr[i*3] = (Math.random()-0.5)*2200;
        posArr[i*3+1] = -80 + Math.random()*420;
        posArr[i*3+2] = (Math.random()-0.5)*2200;
        sizes[i] = Math.random() * (isMobile?6:9) + (isMobile?2:3);
      }
      ptsGeo.setAttribute('position', new THREE.BufferAttribute(posArr,3));
      ptsGeo.setAttribute('size', new THREE.BufferAttribute(sizes,1));

      const sprite = (() => {
        const c = document.createElement('canvas'); c.width=64; c.height=64; const cx = c.getContext('2d');
        const g = cx.createRadialGradient(32,32,2,32,32,32);
        g.addColorStop(0,'rgba(255,220,240,1)'); g.addColorStop(1,'rgba(255,220,240,0)');
        cx.fillStyle = g; cx.fillRect(0,0,64,64);
        return new THREE.CanvasTexture(c);
      })();

      const ptsMat = new THREE.PointsMaterial({ size:isMobile?5:7, map:sprite, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.95 });
      const particles = new THREE.Points(ptsGeo, ptsMat);
      scene.add(particles);

      const targetPos = new Float32Array(PARTICLES*3);

      function genDoubleHeart(){
        for(let i=0;i<PARTICLES;i++){
          const t = (i / PARTICLES) * Math.PI * 2 * (1 + Math.random()*0.2);
          const heart = (θ, s=1) => {
            const x = 16*Math.pow(Math.sin(θ),3);
            const y = 13*Math.cos(θ)-5*Math.cos(2*θ)-2*Math.cos(3*θ)-Math.cos(4*θ);
            return {x:x*s, y:y*s};
          };
          const side = (i % 2 === 0) ? -1 : 1;
          const h = heart(t, 17 * (0.85 + Math.random()*0.35));
          const sx = h.x + side*32 + (Math.random()-0.5)*18;
          const sy = h.y + 70 + (Math.random()-0.5)*28;
          const sz = Math.sin(t*3.1) * 48 + (Math.random()-0.5)*40;
          targetPos[i*3] = sx; targetPos[i*3+1] = sy; targetPos[i*3+2] = sz;
        }
      }

      function genRoseSpiral(){
        for(let i=0;i<PARTICLES;i++){
          const t = i / PARTICLES;
          const turns = 6.0;
          const angle = t * turns * Math.PI * 2;
          const a = 0.22 + Math.random()*0.06;
          const radius = 8 + Math.exp(a * angle) * 1.8;
          const sx = Math.cos(angle) * radius * (0.9 + Math.random()*0.2);
          const sz = Math.sin(angle) * radius * (0.9 + Math.random()*0.2);
          const sy = -20 + Math.sin(angle*0.7) * 24 + (Math.random()-0.5)*26;
          targetPos[i*3] = sx*12; targetPos[i*3+1] = sy + 80; targetPos[i*3+2] = sz*12;
        }
      }

      function genRibbonLoops(){
        for(let i=0;i<PARTICLES;i++){
          const t = i / PARTICLES;
          const loops = 3.5;
          const angle = t * loops * Math.PI*2;
          const r = 120 + Math.sin(angle*2.1)*40 + Math.random()*120;
          const sx = Math.cos(angle) * r + (Math.random()-0.5)*32;
          const sz = Math.sin(angle) * r * 0.6 + (Math.random()-0.5)*32;
          const sy = Math.cos(t*Math.PI*6)*36 + 10 + (Math.random()-0.5)*26;
          targetPos[i*3] = sx; targetPos[i*3+1] = sy; targetPos[i*3+2] = sz;
        }
      }

      function genPetalBloom(){
        for(let i=0;i<PARTICLES;i++){
          const t = i/PARTICLES;
          const petals = 8;
          const angle = t * Math.PI * 2 * (1 + Math.random()*0.4);
          const pet = Math.sin(angle*petals) * (0.6 + Math.random()*0.7);
          const radius = 40 + Math.pow(Math.random(),0.7) * 520 * pet;
          const sx = Math.cos(angle) * radius + (Math.random()-0.5)*28;
          const sz = Math.sin(angle) * radius + (Math.random()-0.5)*28;
          const sy = -20 + Math.sin(t*6)*36 + (Math.random()-0.5)*22;
          targetPos[i*3] = sx; targetPos[i*3+1] = sy + 40; targetPos[i*3+2] = sz;
        }
      }

      const shapeFns = [genDoubleHeart, genRoseSpiral, genRibbonLoops, genPetalBloom];
      let shapeIndex = 0;
      function setShape(i){
        shapeIndex = i % shapeFns.length;
        shapeFns[shapeIndex]();
      }
      setShape(0);

      const cycleMs = 6000;
      setInterval(()=> setShape((shapeIndex+1) % shapeFns.length), cycleMs);

      let pointerDown=false, pointerStart=null;
      let targetYaw = 0, targetPitch = 0, yaw = 0, pitch = 0;
      const maxPitch = Math.PI/2 - 0.08;

      function clientPoint(e){ if(e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY }; return { x: e.clientX, y: e.clientY }; }

      function onPointerDown(e){ pointerDown=true; pointerStart=clientPoint(e); }
      function onPointerMove(e){
        const p = clientPoint(e);
        const rect = renderer.domElement.getBoundingClientRect();
        const mx = (p.x - rect.left) / rect.width;
        const my = (p.y - rect.top) / rect.height;
        if(pointerDown && e.type.startsWith('touch')){
          const dx = (p.x - pointerStart.x) / window.innerWidth;
          const dy = (p.y - pointerStart.y) / window.innerHeight;
          targetYaw = -dx * Math.PI * 1.1;
          targetPitch = -dy * Math.PI * 0.95;
        } else {
          targetYaw = -(mx - 0.5) * Math.PI * 1.05;
          targetPitch = -(my - 0.5) * Math.PI * 0.85;
        }
        targetPitch = Math.max(-maxPitch, Math.min(maxPitch, targetPitch));
      }
      function onPointerUp(){ pointerDown=false; pointerStart=null; }

      renderer.domElement.addEventListener('pointerdown', onPointerDown, {passive:true});
      renderer.domElement.addEventListener('pointermove', onPointerMove, {passive:true});
      window.addEventListener('pointerup', onPointerUp, {passive:true});

      let pinchStart = 0, startRadius = cameraRadius;
      function distTouches(t){ const dx = t[0].clientX - t[1].clientX; const dy = t[0].clientY - t[1].clientY; return Math.sqrt(dx*dx + dy*dy); }
      renderer.domElement.addEventListener('touchstart', (e)=>{ if(e.touches && e.touches.length===2){ pinchStart = distTouches(e.touches); startRadius = cameraRadius; } }, {passive:true});
      renderer.domElement.addEventListener('touchmove', (e)=>{ if(e.touches && e.touches.length===2 && pinchStart>0){ const d = distTouches(e.touches); const f = pinchStart / Math.max(1,d); cameraRadius = startRadius * f; cameraRadius = Math.max(380, Math.min(1800, cameraRadius)); } }, {passive:true});
      renderer.domElement.addEventListener('wheel', (e)=>{ e.preventDefault(); cameraRadius += e.deltaY * 0.6; cameraRadius = Math.max(380, Math.min(1800, cameraRadius)); }, {passive:false});

      const raycaster = new THREE.Raycaster();
      function onClick(ev){
        const p = clientPoint(ev);
        const rect = renderer.domElement.getBoundingClientRect();
        const mx = ((p.x - rect.left) / rect.width) * 2 - 1;
        const my = -(((p.y - rect.top) / rect.height) * 2 - 1);
        raycaster.setFromCamera({ x: mx, y: my }, camera);
        const ints = raycaster.intersectObjects(imagesGroup.children, true);
        if(ints.length>0){
          let obj = ints[0].object;
          while(obj && (!obj.userData || !obj.userData.url)) obj = obj.parent;
          if(obj && obj.userData && obj.userData.url) openPreview(obj.userData.url);
          if(obj){ obj.scale.setScalar(1.06); setTimeout(()=>obj.scale.setScalar(1.0), 200); }
        }
      }
      renderer.domElement.addEventListener('click', onClick, {passive:true});

      const previewModal = document.getElementById('previewModal');
      const previewImage = document.getElementById('previewImage');
      const previewClose = document.getElementById('previewClose');
      function openPreview(url){ previewImage.src = url; previewModal.style.display = 'flex'; previewModal.setAttribute('aria-hidden','false'); }
      function closePreview(){ previewModal.style.display = 'none'; previewImage.src=''; previewModal.setAttribute('aria-hidden','true'); }
      previewClose.addEventListener('click', closePreview);
      previewModal.addEventListener('click', (e)=>{ if(e.target===previewModal) closePreview(); });
      window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closePreview(); });

      const toggleAutoBtn = document.getElementById('toggleAuto');
      const nextShapeBtn = document.getElementById('nextShape');
      const returnBtn = document.getElementById('returnBtn');
      let auto = true;
      toggleAutoBtn.addEventListener('click', ()=>{ auto = !auto; toggleAutoBtn.textContent = auto ? 'Detener' : 'Auto-rotar'; toggleAutoBtn.setAttribute('aria-pressed', String(auto)); });
      nextShapeBtn.addEventListener('click', ()=> { setShape((shapeIndex+1) % shapeFns.length); });

      returnBtn.addEventListener('click', ()=> window.parent.postMessage({ type: 'doorClosed' }, '*'));

      let last = performance.now();
      let morphSpeed = isMobile ? 0.06 : 0.12;
      function animate(){
        requestAnimationFrame(animate);
        const now = performance.now();
        const dt = Math.max(0.001, (now - last)/1000);
        last = now;

        const lerp = 1 - Math.pow(0.001, dt * 60);
        yaw += (targetYaw - yaw) * lerp;
        pitch += (targetPitch - pitch) * lerp;
        if(auto) yaw -= dt * 0.02;
        const cp = Math.max(-maxPitch, Math.min(maxPitch, pitch));
        const r = cameraRadius;
        const cx = Math.sin(yaw) * r, cz = Math.cos(yaw) * r, cy = -cp * 220 + 60;
        camera.position.set(cx, cy, cz);
        camera.lookAt(0, 0, 0);

        const pos = ptsGeo.attributes.position.array;
        for(let i=0;i<PARTICLES;i++){
          const idx = i*3;
          const tx = targetPos[idx], ty = targetPos[idx+1], tz = targetPos[idx+2];
          const nx = (Math.random()-0.5)*0.04;
          const ny = (Math.random()-0.5)*0.04;
          const nz = (Math.random()-0.5)*0.04;
          pos[idx]   += (tx - pos[idx])   * morphSpeed + nx;
          pos[idx+1] += (ty - pos[idx+1]) * morphSpeed + ny;
          pos[idx+2] += (tz - pos[idx+2]) * morphSpeed + nz;
        }
        ptsGeo.attributes.position.needsUpdate = true;

        ring.rotation.z += 0.00006;
        stars.rotation.y += 0.0001;
        imagesGroup.children.forEach((g,i)=>{ g.lookAt(camera.position); g.position.y += Math.sin(i*0.6 + now*0.00085) * 0.0016; });

        renderer.render(scene, camera);
      }
      animate();

      function pulseMorph(){ morphSpeed = isMobile ? 0.16 : 0.28; setTimeout(()=> morphSpeed = isMobile ? 0.06 : 0.12, 600); }
      const _setShape = setShape;
      setShape = function(i){ _setShape(i); pulseMorph(); };

      window.addEventListener('resize', ()=> {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
      });

      window._puertaRomanticaV2 = { setShape, shapes: shapeFns.map((f,i)=>i), particles: PARTICLES, images: TOTAL_IMAGES };
    })();
  </script>
</body>
</html>

