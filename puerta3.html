<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puerta 4 — Romántico (Espiral-Flor sorpresa)</title>
  <style>
    :root{
      --accent1:#ffd6ea;
      --accent2:#ffd9a6;
      --panel: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;background:
      radial-gradient(900px 600px at 20% 12%, rgba(255,150,200,0.02), transparent 8%),
      linear-gradient(180deg,#050018,#04000b);overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#fdeef6}
    #canvas-container{width:100vw;height:100vh;position:relative;display:block;touch-action:none}
    /* top panel */
    #overlay{
      position:absolute; left:18px; top:18px; z-index:220;
      padding:12px;border-radius:14px; background: linear-gradient(180deg,var(--panel), rgba(0,0,0,0.12));
      backdrop-filter: blur(6px); box-shadow: 0 16px 50px rgba(0,0,0,0.6); color:#fff; min-width:220px;
    }
    #overlay h3{margin:0 0 8px 0;font-size:15px;color:var(--accent1)}
    #overlay p{margin:0;font-size:13px;opacity:0.95}
    .controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
    .btn, .btn-ghost {
      position:relative;overflow:hidden;display:inline-flex;align-items:center;gap:8px;padding:9px 12px;border-radius:12px;border:0;cursor:pointer;font-weight:700;font-size:14px;
      -webkit-tap-highlight-color: transparent; transition: transform .12s ease, box-shadow .12s ease;
    }
    .btn { background: linear-gradient(180deg,#ffd6ea,#ffd9a6); color:#111; box-shadow: 0 10px 30px rgba(255,160,190,0.08) }
    .btn:hover{ transform: translateY(-3px) }
    .btn-ghost{ background:transparent;border:1px solid rgba(255,255,255,0.06); color:#fff; padding:8px 10px }
    .btn-ghost:hover{ background: rgba(255,255,255,0.02); transform: translateY(-2px) }

    .ripple{ position:absolute;border-radius:999px;transform:scale(0);animation:rip .6s ease-out;pointer-events:none;background:rgba(255,255,255,0.14) }
    @keyframes rip{ to{ transform:scale(2.6); opacity:0 } }

    #credits{position:absolute;right:16px;bottom:18px;color:#f8e1ea;font-size:12px;z-index:200;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(0,0,0,0.06))}
    #hint{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;color:#ffdfe8;z-index:200;font-size:13px;padding:8px 14px;border-radius:999px;background:linear-gradient(90deg, rgba(255,166,200,0.04), rgba(255,220,170,0.03));backdrop-filter:blur(2px)}
    #previewModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.95));z-index:350}
    #previewContent{max-width:94vw;max-height:92vh;padding:16px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;flex-direction:column;gap:12px;box-shadow:0 30px 90px rgba(0,0,0,0.8)}
    #previewContent img{max-width:100%;max-height:82vh;border-radius:10px;display:block;box-shadow:0 18px 50px rgba(0,0,0,0.6)}
    #previewClose{align-self:flex-end;padding:8px 12px;border-radius:10px;border:0;background:linear-gradient(180deg,#ffd6ea,#ffd9a6);color:#111;cursor:pointer}

    @media (max-width:720px){
      #overlay{left:12px;top:12px;padding:10px}
      .btn{padding:9px 10px;font-size:14px}
      #hint{display:none}
    }
  </style>
</head>
<body>
  <div id="canvas-container" aria-hidden="false"></div>

  <div id="overlay" role="region" aria-label="Controles">
    <h3>Puerta 4 — Espiral-Flor romántica</h3>
    <p>Toca/arrastra para mirar. Pellizca para acercar/alejar.</p>
    <div class="controls">
      <button id="toggleAuto" class="btn" aria-pressed="false">Auto-rotar</button>
      <button id="shapeBtn" class="btn-ghost">Cambiar forma</button>
      <button id="surpriseBtn" class="btn-ghost">Sorpresa</button>
      <button id="returnBtn" class="btn-ghost">Regresar</button>
    </div>
  </div>

  <div id="credits">Diseño romántico • Imágenes: picsum.photos (ejemplos)</div>
  <div id="hint">Pulsa una imagen para ampliar</div>

  <div id="previewModal" aria-hidden="true">
    <div id="previewContent"><button id="previewClose">Cerrar</button><img id="previewImage" src="" alt="Vista previa"></div>
  </div>

  <!-- three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
  (function(){
    // ---------- Config ----------
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 720;
    const IMAGE_POOL = [
      'https://picsum.photos/id/1015/900/600','https://picsum.photos/id/1025/900/600','https://picsum.photos/id/1035/900/600',
      'https://picsum.photos/id/1041/900/600','https://picsum.photos/id/1050/900/600','https://picsum.photos/id/1069/900/600',
      'https://picsum.photos/id/1074/900/600','https://picsum.photos/id/1084/900/600'
    ];
    const TOTAL = isMobile ? 12 : 20;
    const FRAME_W = isMobile ? 220 : 320;
    const FRAME_H = isMobile ? 150 : 210;
    let cameraRadius = isMobile ? 980 : 820;

    // ---------- Renderer ----------
    const container = document.getElementById('canvas-container');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1.5, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.display = 'block';
    renderer.domElement.style.touchAction = 'none';
    container.appendChild(renderer.domElement);

    // ---------- Scene & Camera ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020012);
    scene.fog = new THREE.FogExp2(0x020012, 0.00016);

    const camera = new THREE.PerspectiveCamera(68, window.innerWidth/window.innerHeight, 0.1, 12000);
    camera.position.set(0, 60, cameraRadius);

    // lights
    const hemi = new THREE.HemisphereLight(0xfff2fb, 0x07101b, 0.55); scene.add(hemi);
    const amb = new THREE.AmbientLight(0xffeaf4, 0.18); scene.add(amb);
    const key = new THREE.PointLight(0xffcbe6, 0.9, 2000); key.position.set(700, 300, 300); scene.add(key);

    // floor + soft ring
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(2600,2600), new THREE.MeshStandardMaterial({ color:0x04020a, roughness:0.18 }));
    floor.rotation.x = -Math.PI/2; floor.position.y = -420; scene.add(floor);
    const ring = new THREE.Mesh(new THREE.TorusGeometry(900, 16, 40, 300), new THREE.MeshStandardMaterial({ color:0xffb0d1, emissive:0xffe0c8, emissiveIntensity:0.08, roughness:0.45 }));
    ring.rotation.x = Math.PI/2; ring.position.y = -80; scene.add(ring);

    // ---------- Nice background dots ----------
    const starsCount = isMobile ? 300 : 700;
    const starsGeo = new THREE.BufferGeometry(), starsPos = new Float32Array(starsCount*3);
    for(let i=0;i<starsCount;i++){
      const r = 400 + Math.random()*2000;
      const theta = Math.random()*Math.PI*2;
      const phi = Math.acos(2*Math.random()-1);
      starsPos[i*3] = Math.sin(phi)*Math.cos(theta)*r;
      starsPos[i*3+1] = Math.sin(phi)*Math.sin(theta)*r*0.55;
      starsPos[i*3+2] = Math.cos(phi)*r;
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos,3));
    const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({ size: isMobile?2.0:3.0, color:0xffffff, opacity:0.95, transparent:true }));
    scene.add(stars);

    // ---------- Group for images ----------
    const imagesGroup = new THREE.Group(); scene.add(imagesGroup);
    const loader = new THREE.TextureLoader(); loader.setCrossOrigin('');

    // ---------- Surprise ribbons: thin planes that wave ----------
    const ribbons = new THREE.Group(); scene.add(ribbons);
    function addRibbon(radius, height, twist, colorA, colorB){
      const seg = 80;
      const geo = new THREE.PlaneGeometry(radius*2, height, seg, 4);
      // triangular UV warp will allow subtle gradient-like look with MeshStandardMaterial
      const mat = new THREE.MeshStandardMaterial({ color: colorA, metalness:0.05, roughness:0.4, side: THREE.DoubleSide, transparent:true, opacity:0.85 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = Math.PI/2;
      mesh.position.y = -80;
      mesh.userData = { twist };
      ribbons.add(mesh);
    }
    for(let i=0;i<3;i++){
      addRibbon(520 + i*60, 240 + i*60, (i%2?0.8:-0.8)*(0.6 + i*0.2), 0xffc2d9, 0xffe8b0);
    }

    // ---------- Heart canopy particles ----------
    const heartParticles = new THREE.BufferGeometry();
    const heartCount = isMobile ? 220 : 520;
    const heartPos = new Float32Array(heartCount*3);
    function sampleHeart(u){
      // parametric heart shape roughly centered above (u 0..1)
      const t = u * Math.PI * 2;
      const x = 16*Math.pow(Math.sin(t),3);
      const y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
      return new THREE.Vector3(x*18 + (Math.random()-0.5)*24, y*14 + 80 + (Math.random()-0.5)*26, Math.sin(t*3.1)*36 + (Math.random()-0.5)*40);
    }
    for(let i=0;i<heartCount;i++){
      const v = sampleHeart(i/heartCount);
      heartPos[i*3] = v.x; heartPos[i*3+1] = v.y; heartPos[i*3+2] = v.z;
    }
    heartParticles.setAttribute('position', new THREE.BufferAttribute(heartPos,3));
    const heartMat = new THREE.PointsMaterial({ size: isMobile?6:8, map: (() => {
      // create soft dot
      const c = document.createElement('canvas'); c.width=64; c.height=64; const cx=c.getContext('2d');
      const g = cx.createRadialGradient(32,32,2,32,32,32); g.addColorStop(0,'rgba(255,200,230,1)'); g.addColorStop(1,'rgba(255,200,230,0)');
      cx.fillStyle=g; cx.fillRect(0,0,64,64);
      return new THREE.CanvasTexture(c);
    })(), transparent:true, depthWrite:false, opacity:0.9 });
    const heartPts = new THREE.Points(heartParticles, heartMat);
    scene.add(heartPts);

    // ---------- Frames creation ----------
    function createFrame(url, pos, idx){
      const glow = new THREE.Mesh(new THREE.PlaneGeometry(FRAME_W*1.12, FRAME_H*1.12), new THREE.MeshBasicMaterial({ color:0xffd6ea, transparent:true, opacity:0.08, side:THREE.DoubleSide }));
      const frame = new THREE.Mesh(new THREE.BoxGeometry(FRAME_W*1.03, FRAME_H*1.04, 12), new THREE.MeshStandardMaterial({ color:0x201218, roughness:0.18, metalness:0.6 }));
      const imgMat = new THREE.MeshBasicMaterial({ color:0xffffff });
      const img = new THREE.Mesh(new THREE.PlaneGeometry(FRAME_W-14, FRAME_H-14), imgMat);
      const g = new THREE.Group();
      glow.position.set(0,8,-6); frame.position.set(0,0,-8); img.position.set(0,0,6);
      g.add(glow, frame, img);
      g.position.copy(pos);
      g.userData = { url, idx };
      loader.load(url, tex => { imgMat.map = tex; imgMat.needsUpdate = true; });
      imagesGroup.add(g);
      return g;
    }

    // ---------- Arrangement: spiral-flower  (unique) ----------
    let layout = 'spiral'; // options: 'spiral' (this version), 'doubleHelix'
    function arrange(layoutMode='spiral'){
      while(imagesGroup.children.length) imagesGroup.remove(imagesGroup.children[0]);
      const placed = [];
      for(let i=0;i<TOTAL;i++){
        const t = i / TOTAL;
        let pos;
        if(layoutMode === 'spiral'){
          const turns = 3.2;
          const angle = t * turns * Math.PI * 2;
          const radius = 60 + Math.pow(t,0.6) * 560;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          const y = -120 + Math.sin(t*Math.PI*6)*18 + (1 - t) * 160;
          pos = new THREE.Vector3(x + (Math.random()-0.5)*24, y, z + (Math.random()-0.5)*24);
        } else { // doubleHelix
          const turns = 2.0;
          const angle = t * turns * Math.PI * 2;
          const radius = 180 + Math.sin(t*Math.PI*4) * 220;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          const y = -180 + t*420;
          pos = new THREE.Vector3(x + (Math.random()-0.5)*30, y + Math.sin(i)*10, z + (Math.random()-0.5)*30);
        }
        // mild collision avoidance
        let attempts = 0;
        while(placed.some(p=>p.distanceTo(pos) < 140) && attempts < 40){
          pos.x += (Math.random()-0.5)*40; pos.z += (Math.random()-0.5)*40; attempts++;
        }
        placed.push(pos.clone());
        createFrame(IMAGE_POOL[i % IMAGE_POOL.length], pos, i);
      }
    }
    arrange(layout);

    // ---------- Simple animate / interaction ----------
    let targetYaw = 0, targetPitch = 0, yaw = 0, pitch = 0;
    const maxPitch = Math.PI/2 - 0.08;
    let isPointerDown = false, pointerStart = null;
    function clientPoint(e){
      if(e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      if(e.changedTouches && e.changedTouches.length) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
      return { x: e.clientX, y: e.clientY };
    }
    function onPointerMove(e){
      const p = clientPoint(e);
      const rect = renderer.domElement.getBoundingClientRect();
      const mx = (p.x - rect.left) / rect.width;
      const my = (p.y - rect.top) / rect.height;
      if(e.pointerType === 'mouse' || (!e.touches && !e.pointerType)){
        targetYaw = -(mx - 0.5) * Math.PI * 1.05;
        targetPitch = -(my - 0.5) * Math.PI * 0.85;
        targetPitch = Math.max(-maxPitch, Math.min(maxPitch, targetPitch));
      } else {
        if(isPointerDown && pointerStart){
          const dx = (p.x - pointerStart.x) / window.innerWidth;
          const dy = (p.y - pointerStart.y) / window.innerHeight;
          targetYaw = -dx * Math.PI * 1.05;
          targetPitch = -dy * Math.PI * 0.95;
          targetPitch = Math.max(-maxPitch, Math.min(maxPitch, targetPitch));
        }
      }
    }
    renderer.domElement.addEventListener('pointermove', onPointerMove, { passive:true });
    renderer.domElement.addEventListener('pointerdown', (e)=>{ isPointerDown = true; pointerStart = clientPoint(e); }, { passive:true });
    window.addEventListener('pointerup', ()=>{ isPointerDown = false; pointerStart = null; }, { passive:true });

    // pinch zoom support
    let pinchStartDist = 0, pinchStartRadius = cameraRadius;
    function getDist(e){ if(!e.touches || e.touches.length<2) return 0; const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; return Math.sqrt(dx*dx + dy*dy); }
    renderer.domElement.addEventListener('touchstart', (e)=>{ if(e.touches && e.touches.length===2){ pinchStartDist = getDist(e); pinchStartRadius = cameraRadius; } }, { passive:true });
    renderer.domElement.addEventListener('touchmove', (e)=>{ if(e.touches && e.touches.length===2 && pinchStartDist>0){ const d = getDist(e); const f = pinchStartDist / Math.max(1,d); cameraRadius = pinchStartRadius * f; cameraRadius = Math.max(380, Math.min(1800, cameraRadius)); } }, { passive:true });

    // wheel zoom
    renderer.domElement.addEventListener('wheel', (e)=>{ e.preventDefault(); cameraRadius += e.deltaY * 0.6; cameraRadius = Math.max(380, Math.min(1800, cameraRadius)); }, { passive:false });

    // click to preview images
    const raycaster = new THREE.Raycaster();
    function onClick(e){
      const p = clientPoint(e);
      const rect = renderer.domElement.getBoundingClientRect();
      const cx = p.x - rect.left, cy = p.y - rect.top;
      const mx = (cx/rect.width)*2 - 1, my = -((cy/rect.height)*2 - 1);
      raycaster.setFromCamera({ x: mx, y: my }, camera);
      const ints = raycaster.intersectObjects(imagesGroup.children, true);
      if(ints.length>0){
        let obj = ints[0].object;
        while(obj && (!obj.userData || !obj.userData.url)) obj = obj.parent;
        if(obj && obj.userData && obj.userData.url) openPreview(obj.userData.url);
        obj && (obj.scale.setScalar(1.06), setTimeout(()=>obj.scale.setScalar(1.0), 220));
      }
      // ripple for UI buttons
      const btn = (e.target || e.srcElement).closest && (e.target || e.srcElement).closest('.btn, .btn-ghost');
      if(btn) createRipple(btn, p.x, p.y);
    }
    renderer.domElement.addEventListener('click', onClick, { passive:true });
    renderer.domElement.addEventListener('touchend', (e)=>{ if(e.changedTouches && e.changedTouches.length) onClick({ changedTouches: e.changedTouches }); }, { passive:true });

    // preview modal
    const previewModal = document.getElementById('previewModal'), previewImage = document.getElementById('previewImage'), previewClose = document.getElementById('previewClose');
    function openPreview(url){ previewImage.src = url; previewModal.style.display = 'flex'; previewModal.setAttribute('aria-hidden','false'); }
    function closePreview(){ previewModal.style.display = 'none'; previewImage.src = ''; previewModal.setAttribute('aria-hidden','true'); }
    previewClose.addEventListener('click', closePreview);
    previewModal.addEventListener('click', (ev)=>{ if(ev.target === previewModal) closePreview(); });

    // ripple for buttons
    function createRipple(btn, clientX, clientY){
      if(!btn) return;
      const rect = btn.getBoundingClientRect();
      const x = clientX - rect.left, y = clientY - rect.top;
      const r = Math.max(rect.width, rect.height);
      const el = document.createElement('span'); el.className = 'ripple';
      el.style.width = el.style.height = (r * 1.6) + 'px';
      el.style.left = (x - r*0.8) + 'px'; el.style.top = (y - r*0.8) + 'px';
      btn.appendChild(el); setTimeout(()=> el.remove(), 700);
    }

    // UI buttons
    const toggleAuto = document.getElementById('toggleAuto');
    const shapeBtn = document.getElementById('shapeBtn');
    const surpriseBtn = document.getElementById('surpriseBtn');
    const returnBtn = document.getElementById('returnBtn');
    let auto = false;
    toggleAuto.addEventListener('click', (e)=>{ createRipple(toggleAuto, e.clientX || window.innerWidth/2, e.clientY || window.innerHeight/2); auto = !auto; toggleAuto.textContent = auto ? 'Detener' : 'Auto-rotar'; toggleAuto.setAttribute('aria-pressed', String(auto)); });

    shapeBtn.addEventListener('click', (e)=>{ createRipple(shapeBtn, e.clientX || window.innerWidth/2, e.clientY || window.innerHeight/2); layout = (layout==='spiral'?'doubleHelix':'spiral'); arrange(layout); });
    surpriseBtn.addEventListener('click', (e)=>{ createRipple(surpriseBtn, e.clientX || window.innerWidth/2, e.clientY || window.innerHeight/2);
      // surprise: fling ribbons and sparkle heart
      ribbons.children.forEach((r,i)=> r.userData && (r.userData._pulse = 1.0));
      // small burst of heart particles outward
      const pos = heartParticles.attributes.position.array;
      for(let i=0;i<heartCount;i++){
        pos[i*3+1] += Math.random()*40 + 10;
      }
      heartParticles.attributes.position.needsUpdate = true;
    });

    // RETURN behavior: keep exactly the same message you used before
    returnBtn.addEventListener('click', (e)=>{ createRipple(returnBtn, e.clientX || window.innerWidth/2, e.clientY || window.innerHeight/2); window.parent.postMessage({ type: 'doorClosed' }, '*'); });

    // ---------- Animation ----------
    let last = performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.max(0.001, (now - last)/1000);
      last = now;

      // camera lerp
      const lerp = 1 - Math.pow(0.001, dt * 60);
      yaw += (targetYaw - yaw) * lerp;
      pitch += (targetPitch - pitch) * lerp;
      if(auto) yaw -= dt * 0.02;
      const cp = Math.max(-maxPitch, Math.min(maxPitch, pitch));

      // spherical camera
      const r = cameraRadius;
      const cx = Math.sin(yaw) * r, cz = Math.cos(yaw) * r, cy = -cp * 220 + 60;
      camera.position.set(cx, cy, cz);
      camera.lookAt(0, 0, 0);

      // ribbons gentle wave and occasional pulse
      ribbons.children.forEach((ribbon, i)=>{
        const off = i * 0.15;
        ribbon.geometry.verticesNeedUpdate = true;
        // animate vertices for slight wave
        const pos = ribbon.geometry.attributes.position;
        const len = pos.count;
        for(let vi=0; vi<len; vi++){
          const idx = vi*3;
          const x0 = ribbon.geometry.parameters.width ? 0 : pos.array[idx];
          pos.array[idx+1] = Math.sin((vi*0.05 + now*0.002) + off) * 6 + (-80 + i*6);
        }
        pos.needsUpdate = true;
        // pulse if set
        if(ribbon.userData && ribbon.userData._pulse){
          ribbon.material.opacity = Math.max(0.3, 0.85 * ribbon.userData._pulse);
          ribbon.userData._pulse = Math.max(0, ribbon.userData._pulse - dt * 0.9);
        } else ribbon.material.opacity = 0.85;
      });

      // heart particles subtle float
      const ppos = heartParticles.attributes.position;
      for(let i=0;i<heartCount;i++){
        const baseY = ppos.array[i*3+1];
        ppos.array[i*3+1] = baseY + Math.sin(now*0.001 + i)*0.02; // tiny float to keep GPU happy
      }
      ppos.needsUpdate = true;

      // images face camera and bob
      imagesGroup.children.forEach((g, idx)=>{
        g.lookAt(camera.position);
        g.position.y += Math.sin(idx*0.6 + now*0.0008) * 0.0018;
      });

      // subtle rotate extras
      ring.rotation && (ring.rotation.z += 0.00006);
      stars.rotation && (stars.rotation.y += 0.00012);

      renderer.render(scene, camera);
    }
    animate();

    // ---------- Resize ----------
    window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });

    // ---------- Preview modal handlers ----------
    window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closePreview(); });

    // Expose helper for debug
    window._puerta4 = { arrange, imagesGroup, heartParticles };

    // ---------- helpers defined earlier references ----------
    // (createRipple, clientPoint, etc.) already in-scope
    // createRipple is used by UI buttons and click handler
    // arrange defined earlier

  })();
  </script>
</body>
</html>
