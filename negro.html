<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Agujero Negro - Efecto CÃ³smico</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let zoom = 1; // Start with no zoom
    let centerX, centerY, minDim, maxSpawnRadius;
    let rotation = Math.PI * 1.5; // Start 270 degrees away
    let isDragging = false;
    let prevX = 0;
    let phase = 'galaxy'; // Phases: 'galaxy', 'rotate', 'zoom', 'fade'
    let phaseTime = 0;
    let blackHoleOpacity = 0; // For fade-in
    let blackHoleX, blackHoleY; // Black hole position
    let initialBlackHoleX, initialBlackHoleY; // Initial offset

    // Updating canvas dimensions
    function updateDimensions() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      centerX = canvas.width / 2;
      centerY = canvas.height / 2;
      minDim = Math.min(canvas.width, canvas.height);
      maxSpawnRadius = Math.max(minDim * 2, minDim / 0.5 + 1200);
      initialBlackHoleX = centerX + minDim * 0.8; // Initial offset to the right
      initialBlackHoleY = centerY;
      blackHoleX = initialBlackHoleX; // Start at offset
      blackHoleY = initialBlackHoleY;
    }
    updateDimensions();
    window.addEventListener('resize', updateDimensions);

    const blackHoleRadius = 180;
    const lightCanvas = document.createElement('canvas');
    const lightCtx = lightCanvas.getContext('2d');
    let lightClouds = [];
    let cloudCounter = 0;
    const maxClouds = 30;

    // Small space stars
    const stars = [];
    for (let i = 0; i < 150; i++) {
      stars.push({
        x: Math.random() * canvas.width * 2,
        y: Math.random() * canvas.height * 2,
        radius: Math.random() * 1.5 + 0.5,
        opacity: Math.random() * 0.8 + 0.2,
        twinkle: Math.random() * 0.02 + 0.01,
        color: Math.random() < 0.7 ? 'white' : 
               Math.random() < 0.5 ? 'rgba(150,150,255,1)' : 'rgba(255,255,150,1)'
      });
    }

    // Shooting stars (meteors)
    let shootingStars = [];
    let shootingStarPasses = 0;
    const maxShootingStarPasses = 5;

    let starTime = 0;
    
    // Drawing small twinkling stars
    function drawStars() {
      starTime += 0.02;
      stars.forEach((star, index) => {
        const twinkle = Math.sin(starTime + index * 0.5) * star.twinkle;
        const currentOpacity = Math.max(0.1, star.opacity + twinkle);
        
        lightCtx.beginPath();
        lightCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        lightCtx.fillStyle = star.color === 'white' ? 
          `rgba(255,255,255,${currentOpacity})` : 
          star.color.replace('1)', `${currentOpacity})`);
        lightCtx.fill();
        
        // Small glow for brighter stars
        if (star.radius > 1) {
          lightCtx.beginPath();
          lightCtx.arc(star.x, star.y, star.radius * 1.5, 0, Math.PI * 2);
          lightCtx.fillStyle = star.color === 'white' ? 
            `rgba(255,255,255,${currentOpacity * 0.3})` : 
            star.color.replace('1)', `${currentOpacity * 0.3})`);
          lightCtx.fill();
        }
      });
    }

    // Update stars position slowly
    function updateStars(dt) {
      stars.forEach(star => {
        star.x -= 0.2 * dt * 60;
        star.y -= 0.1 * dt * 60;
        
        // Wrap around screen
        if (star.x < -50) star.x = canvas.width + 50;
        if (star.y < -50) star.y = canvas.height + 50;
      });
    }

    // Drawing nebula-like clouds with aurora effects
    function drawLightClouds() {
      lightCanvas.width = canvas.width;
      lightCanvas.height = canvas.height;
      
      // Pure black space background
      lightCtx.fillStyle = 'rgba(0,0,0,1)';
      lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);
      
      drawStars();

      lightClouds.forEach(cloud => {
        const segments = 30;
        lightCtx.beginPath();
        for (let i = 0; i < segments; i++) {
          const t = i / (segments - 1);
          const angle = cloud.angle - t * cloud.length / 100 * cloud.speed * 8;
          const radius = cloud.radiusDist - t * 60;
          const x = blackHoleX + radius * Math.cos(angle) + (Math.random() - 0.5) * 30;
          const y = blackHoleY + radius * Math.sin(angle) + (Math.random() - 0.5) * 30;
          if (i === 0) {
            lightCtx.moveTo(x, y);
          } else {
            lightCtx.lineTo(x, y);
          }
        }
        const gradient = lightCtx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.width * 2);
        gradient.addColorStop(0, `rgba(100,255,150,${cloud.opacity * 0.6})`);
        gradient.addColorStop(0.2, `rgba(150,200,255,${cloud.opacity * 0.5})`);
        gradient.addColorStop(0.4, `rgba(200,100,255,${cloud.opacity * 0.4})`);
        gradient.addColorStop(0.6, `rgba(255,150,200,${cloud.opacity * 0.3})`);
        gradient.addColorStop(0.8, `rgba(100,200,255,${cloud.opacity * 0.2})`);
        gradient.addColorStop(1, `rgba(0,100,200,0)`);
        lightCtx.fillStyle = gradient;
        lightCtx.fill();
      });

      // Drawing shooting stars (meteors)
      shootingStars.forEach(star => {
        const gradient = lightCtx.createLinearGradient(
          star.x, star.y,
          star.x - star.length * Math.cos(star.angle), star.y - star.length * Math.sin(star.angle)
        );
        gradient.addColorStop(0, `rgba(255,255,255,${star.opacity})`);
        gradient.addColorStop(0.5, `rgba(150,200,255,${star.opacity * 0.7})`);
        gradient.addColorStop(1, `rgba(255,255,255,0)`);
        lightCtx.beginPath();
        lightCtx.moveTo(star.x, star.y);
        lightCtx.lineTo(star.x - star.length * Math.cos(star.angle), star.y - star.length * Math.sin(star.angle));
        lightCtx.strokeStyle = gradient;
        lightCtx.lineWidth = star.width;
        lightCtx.stroke();
      });
    }

    // Generating a light cloud
    function generateLightCloud() {
      if (cloudCounter >= maxClouds) return;
      const angle = Math.random() * Math.PI * 2;
      const radius = Math.random() * (maxSpawnRadius * 0.6) + maxSpawnRadius * 0.4 + blackHoleRadius * 2;
      lightClouds.push({
        x: blackHoleX + radius * Math.cos(angle),
        y: blackHoleY + radius * Math.sin(angle),
        width: Math.random() * 60 + 60,
        length: Math.random() * 500 + 500,
        angle: angle,
        radiusDist: radius,
        speed: Math.random() * 0.03 + 0.015,
        linearSpeed: Math.random() * 3 + 3,
        opacity: 1,
        life: 700
      });
      cloudCounter++;
    }

    // Generating a shooting star (meteor)
    function generateShootingStar() {
      if (shootingStarPasses >= maxShootingStarPasses) return;
      const side = Math.floor(Math.random() * 4);
      let x, y, angle;
      if (side === 0) { x = Math.random() * canvas.width; y = -50; angle = Math.PI * 0.5 + Math.random() * 0.4 - 0.2; }
      else if (side === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; angle = Math.PI + Math.random() * 0.4 - 0.2; }
      else if (side === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; angle = Math.PI * 1.5 + Math.random() * 0.4 - 0.2; }
      else { x = -50; y = Math.random() * canvas.height; angle = 0 + Math.random() * 0.4 - 0.2; }
      shootingStars.push({
        x: x, y: y,
        width: Math.random() * 5 + 4,
        length: Math.random() * 200 + 180,
        angle: angle,
        speed: 280,
        opacity: 1,
        life: 140
      });
    }

    // Updating light clouds
    function updateLightClouds(dt) {
      lightClouds = lightClouds.filter(cloud => cloud.life > 0);
      lightClouds.forEach(cloud => {
        const spiralFactor = blackHoleRadius / Math.max(cloud.radiusDist, blackHoleRadius);
        cloud.angle += cloud.speed * dt * 60 * spiralFactor * 1.5;
        cloud.radiusDist -= 0.3 * dt * 60;
        cloud.x += cloud.linearSpeed * Math.cos(cloud.angle + Math.PI / 2) * dt * 60;
        cloud.y += cloud.linearSpeed * Math.sin(cloud.angle + Math.PI / 2) * dt * 60;
        cloud.life -= dt * 60;
        cloud.opacity = Math.min(1, cloud.life / 350);
        cloud.width = Math.max(30, cloud.width * (cloud.life / 700));
        if (cloud.radiusDist < blackHoleRadius) {
          cloud.life = 0;
        } else {
          cloud.x = blackHoleX + cloud.radiusDist * Math.cos(cloud.angle);
          cloud.y = blackHoleY + cloud.radiusDist * Math.sin(cloud.angle);
        }
      });
      if (Math.random() < 0.15 && cloudCounter < maxClouds) {
        generateLightCloud();
      }
    }

    // Updating shooting stars
    function updateShootingStars(dt) {
      shootingStars = shootingStars.filter(star => star.life > 0);
      shootingStars.forEach(star => {
        star.x -= star.speed * Math.cos(star.angle) * dt * 60;
        star.y -= star.speed * Math.sin(star.angle) * dt * 60;
        star.life -= dt * 60;
        star.opacity = star.life / 140;
        if (star.x < -100 || star.x > canvas.width + 100 || star.y < -100 || star.y > canvas.height + 100) {
          star.life = 0;
          if (shootingStarPasses < maxShootingStarPasses) shootingStarPasses++;
        }
      });
      if (shootingStars.length === 0 && shootingStarPasses < maxShootingStarPasses) {
        generateShootingStar();
      }
    }

    // Initialize clouds and shooting star
    for (let i = 0; i < maxClouds; i++) {
      generateLightCloud();
    }
    generateShootingStar();

    // Disable dragging during animation
    canvas.addEventListener('mousedown', (e) => {
      if (phase === 'fade') {
        isDragging = true;
        prevX = e.clientX;
      }
    });
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging && phase === 'fade') {
        const dx = e.clientX - prevX;
        rotation += dx * 0.002;
        rotation = rotation % (Math.PI * 2);
        prevX = e.clientX;
      }
    });
    canvas.addEventListener('mouseup', () => { isDragging = false; });
    canvas.addEventListener('mouseleave', () => { isDragging = false; });
    canvas.addEventListener('touchstart', (e) => {
      if (phase === 'fade') {
        isDragging = true;
        prevX = e.touches[0].clientX;
      }
    });
    canvas.addEventListener('touchmove', (e) => {
      if (isDragging && phase === 'fade') {
        const dx = e.touches[0].clientX - prevX;
        rotation += dx * 0.002;
        rotation = rotation % (Math.PI * 2);
        prevX = e.touches[0].clientX;
      }
    });
    canvas.addEventListener('touchend', () => { isDragging = false; });

    let auroraTime = 0;
    
    // Space background with aurora clouds
    function drawBackground() {
      // Pure black space
      ctx.fillStyle = 'rgba(0,0,0,1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.drawImage(lightCanvas, 0, 0);
      
      auroraTime += 0.008;
      
      // Subtle aurora clouds floating in space
      for (let i = 0; i < 3; i++) {
        const cloudX = centerX + Math.sin(auroraTime * 0.3 + i * 2) * canvas.width * 0.3;
        const cloudY = centerY + Math.cos(auroraTime * 0.2 + i * 1.5) * canvas.height * 0.2;
        
        const cloudGradient = ctx.createRadialGradient(
          cloudX, cloudY, 50,
          cloudX, cloudY, 300 + i * 100
        );
        cloudGradient.addColorStop(0, `rgba(100,255,150,${0.05 + Math.sin(auroraTime + i) * 0.03})`);
        cloudGradient.addColorStop(0.3, `rgba(150,200,255,${0.04 + Math.cos(auroraTime * 0.8 + i) * 0.02})`);
        cloudGradient.addColorStop(0.6, `rgba(200,100,255,${0.03 + Math.sin(auroraTime * 0.9 + i) * 0.015})`);
        cloudGradient.addColorStop(1, 'rgba(255,150,200,0)');
        ctx.fillStyle = cloudGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      // Distant aurora ribbons
      const ribbonGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      ribbonGradient.addColorStop(0, 'rgba(100,255,150,0)');
      ribbonGradient.addColorStop(0.3, `rgba(150,200,255,${0.02 + Math.sin(auroraTime * 1.2) * 0.01})`);
      ribbonGradient.addColorStop(0.7, `rgba(200,100,255,${0.02 + Math.cos(auroraTime * 0.9) * 0.01})`);
      ribbonGradient.addColorStop(1, 'rgba(100,200,255,0)');
      ctx.fillStyle = ribbonGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Drawing black hole with opacity
    function drawBlackHole(opacity) {
      ctx.globalAlpha = opacity;
      const eventHorizonGradient = ctx.createRadialGradient(
        blackHoleX, blackHoleY, blackHoleRadius - 12,
        blackHoleX, blackHoleY, blackHoleRadius + 6
      );
      eventHorizonGradient.addColorStop(0, 'rgba(0,0,0,1)');
      eventHorizonGradient.addColorStop(0.7, 'rgba(30,15,0,0.9)');
      eventHorizonGradient.addColorStop(0.85, 'rgba(60,30,0,0.7)');
      eventHorizonGradient.addColorStop(0.95, 'rgba(100,50,0,0.4)');
      eventHorizonGradient.addColorStop(1, 'rgba(140,70,0,0)');
      ctx.beginPath();
      ctx.arc(blackHoleX, blackHoleY, blackHoleRadius + 6, 0, Math.PI * 2);
      ctx.fillStyle = eventHorizonGradient;
      ctx.fill();

      const photonRingGradient = ctx.createRadialGradient(
        blackHoleX, blackHoleY, blackHoleRadius - 2,
        blackHoleX, blackHoleY, blackHoleRadius + 2
      );
      photonRingGradient.addColorStop(0, 'rgba(0,0,0,1)');
      photonRingGradient.addColorStop(0.4, 'rgba(0,0,0,1)');
      photonRingGradient.addColorStop(0.7, 'rgba(255,140,0,0.8)');
      photonRingGradient.addColorStop(0.85, 'rgba(255,180,0,0.6)');
      photonRingGradient.addColorStop(0.95, 'rgba(255,220,0,0.3)');
      photonRingGradient.addColorStop(1, 'rgba(255,255,0,0)');
      ctx.beginPath();
      ctx.arc(blackHoleX, blackHoleY, blackHoleRadius + 2, 0, Math.PI * 2);
      ctx.fillStyle = photonRingGradient;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(blackHoleX, blackHoleY, blackHoleRadius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,1)';
      ctx.fill();

      const innerShadowGradient = ctx.createRadialGradient(
        blackHoleX, blackHoleY, blackHoleRadius - 15,
        blackHoleX, blackHoleY, blackHoleRadius
      );
      innerShadowGradient.addColorStop(0, 'rgba(0,0,0,1)');
      innerShadowGradient.addColorStop(0.8, 'rgba(0,0,0,1)');
      innerShadowGradient.addColorStop(0.95, 'rgba(15,7,0,0.8)');
      innerShadowGradient.addColorStop(1, 'rgba(30,15,0,0.3)');
      ctx.beginPath();
      ctx.arc(blackHoleX, blackHoleY, blackHoleRadius, 0, Math.PI * 2);
      ctx.fillStyle = innerShadowGradient;
      ctx.fill();

      ctx.strokeStyle = `rgba(255,140,0,${(0.3 + Math.sin(auroraTime * 2.5) * 0.2) * opacity})`;
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(blackHoleX, blackHoleY, blackHoleRadius + 1, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
    }

    let lastTime = performance.now();

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      phaseTime += dt;

      // Phase control
      if (phase === 'galaxy' && phaseTime >= 5) {
        phase = 'rotate';
        phaseTime = 0;
      } else if (phase === 'rotate' && phaseTime >= 4) {
        phase = 'zoom';
        phaseTime = 0;
      } else if (phase === 'zoom' && zoom >= 12) {
        phase = 'fade';
        phaseTime = 0;
      }

      // Update rotation and center black hole during rotate phase
      if (phase === 'rotate') {
        rotation += (0 - rotation) * 0.02; // Smooth rotation
        blackHoleOpacity = Math.min(1, phaseTime / 3);
        // Move black hole to center during rotation
        const t = Math.min(1, phaseTime / 4); // Normalize over 4 seconds
        blackHoleX = initialBlackHoleX + (centerX - initialBlackHoleX) * t;
        blackHoleY = initialBlackHoleY + (centerY - initialBlackHoleY) * t;
      } else if (phase !== 'galaxy') {
        blackHoleOpacity = 1;
        blackHoleX = centerX; // Ensure centered after rotate
        blackHoleY = centerY;
      }

      // Update zoom
      if (phase === 'zoom') {
        zoom += 0.02 * dt * 60; // Reduced zoom speed for smoother, longer zoom
      }

      // Update elements
      updateStars(dt);
      updateLightClouds(dt);
      updateShootingStars(dt);

      drawBackground();
      drawLightClouds();

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(rotation);
      ctx.scale(zoom, zoom);
      ctx.translate(-centerX, -centerY);

      // Draw black hole
      if (phase !== 'galaxy') {
        const glowRadius = blackHoleRadius * 5;
        ctx.globalAlpha = blackHoleOpacity;
        const glowGradient = ctx.createRadialGradient(blackHoleX, blackHoleY, blackHoleRadius * 0.3, blackHoleX, blackHoleY, glowRadius);
        glowGradient.addColorStop(0, `rgba(255,215,0,${0.7 + Math.sin(auroraTime * 1.8) * 0.1})`);
        glowGradient.addColorStop(0.4, `rgba(255,165,0,${0.6 + Math.cos(auroraTime * 1.3) * 0.15})`);
        glowGradient.addColorStop(0.7, `rgba(200,100,255,${0.5 + Math.sin(auroraTime * 1.6) * 0.15})`);
        glowGradient.addColorStop(1, `rgba(100,200,255,0)`);
        ctx.beginPath();
        ctx.arc(blackHoleX, blackHoleY, glowRadius, 0, Math.PI * 2);
        ctx.fillStyle = glowGradient;
        ctx.fill();
        ctx.globalAlpha = 1;
        drawBlackHole(blackHoleOpacity);
      }

      ctx.restore();

      // Fade to black
      if (phase === 'fade') {
        const fadeOpacity = Math.min(1, phaseTime / 3);
        ctx.fillStyle = `rgba(0,0,0,${fadeOpacity})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    lastTime = performance.now();
    animate();
  </script>
</body>
</html>
