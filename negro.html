<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Agujero Negro - Fotos succionadas</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let zoom = 0.002;
    let centerX, centerY, minDim, maxSpawnRadius;

    function updateDimensions() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      centerX = canvas.width / 2;
      centerY = canvas.height / 2;
      minDim = Math.min(canvas.width, canvas.height);
      maxSpawnRadius = Math.max(minDim * 1.2, minDim / 0.5 + 800);
    }

    updateDimensions();
    window.addEventListener('resize', updateDimensions);

    const blackHoleRadius = 250;

    const starCanvas = document.createElement('canvas');
    const starCtx = starCanvas.getContext('2d');
    let stars = [];

    function drawStars() {
      starCanvas.width = canvas.width;
      starCanvas.height = canvas.height;
      starCtx.fillStyle = 'black';
      starCtx.fillRect(0, 0, starCanvas.width, starCanvas.height);
      stars.forEach(star => {
        starCtx.beginPath();
        starCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        starCtx.fillStyle = `rgba(255,255,255,${star.opacity})`;
        starCtx.fill();
      });
    }

    function generateStars() {
      stars = [];
      for (let i = 0; i < 200; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 1.5 + 0.5,
          opacity: Math.random() * 0.5 + 0.2
        });
      }
      drawStars();
    }

    generateStars();
    window.addEventListener('resize', () => {
      updateDimensions();
      generateStars();
    });

    let auroraTime = 0;
    function drawBackground() {
      ctx.drawImage(starCanvas, 0, 0);
      auroraTime += 0.01;
      const auroraStart = blackHoleRadius * 4;
      const gradient = ctx.createRadialGradient(centerX, centerY, auroraStart, centerX, centerY, canvas.width);
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(0.3, `rgba(255,105,180,${0.28 + Math.sin(auroraTime) * 0.1})`);
      gradient.addColorStop(0.5, `rgba(255,182,193,${0.18 + Math.cos(auroraTime * 0.8) * 0.1})`);
      gradient.addColorStop(0.7, `rgba(219,112,147,${0.18 + Math.sin(auroraTime * 1.2) * 0.1})`);
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    const imageURLs = [
      'https://picsum.photos/seed/antony1/96',
      'https://picsum.photos/seed/antony2/96',
      'https://picsum.photos/seed/antony3/96'
    ];
    const images = [];
    let imagesLoaded = false;

    function loadImages() {
      const promises = imageURLs.map((url, i) => {
        return new Promise(resolve => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { images[i] = img; resolve(); };
          img.onerror = () => {
            const fallback = document.createElement('canvas');
            fallback.width = 96;
            fallback.height = 96;
            const fctx = fallback.getContext('2d');
            fctx.fillStyle = '#333';
            fctx.fillRect(0,0,96,96);
            fctx.fillStyle = '#fff';
            fctx.font = '14px sans-serif';
            fctx.fillText('img', 36, 56);
            const imgObj = new Image();
            imgObj.src = fallback.toDataURL();
            images[i] = imgObj;
            resolve();
          };
          img.src = url;
        });
      });
      return Promise.all(promises).then(() => { imagesLoaded = true; });
    }

    class Particle {
      constructor(index) {
        this.index = index;
        this.resetToOuter();
        this.speed = Math.random() * 0.015 + 0.005;
        this.inwardSpeed = Math.random() * 0.4 + 0.15;
        this.size = Math.random() * 2 + 1;
        this.color = 'rgba(0,191,255,0.95)';
        this.imgIndex = index % imageURLs.length;
        this.imageEvery = 80;
        this.showImage = (index % this.imageEvery) === 0;
        const simulatedTime = 120;
        this.angle = Math.random() * Math.PI * 2;
        this.angle += this.speed * simulatedTime * 60;
        this.radius -= this.inwardSpeed * simulatedTime * 60;
        if (this.radius < blackHoleRadius) this.resetToOuter();
      }

      resetToOuter() {
        this.angle = Math.random() * Math.PI * 2;
        this.radius = Math.random() * (maxSpawnRadius * 0.6) + maxSpawnRadius * 0.4 + blackHoleRadius;
      }

      update(dt) {
        this.angle += this.speed * dt * 60;
        this.radius -= this.inwardSpeed * dt * 60;
        if (this.radius < blackHoleRadius) {
          this.resetToOuter();
        }
      }

      draw() {
        const x = centerX + this.radius * Math.cos(this.angle);
        const y = centerY + this.radius * Math.sin(this.angle);

        ctx.beginPath();
        ctx.arc(x, y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();

        if (imagesLoaded && this.showImage) {
          const img = images[this.imgIndex];
          if (!img) return;

          const denom = Math.max(1, (maxSpawnRadius - blackHoleRadius));
          let normalized = (this.radius - blackHoleRadius) / denom;
          normalized = Math.max(0, Math.min(1, normalized));

          const minImgSize = 8;
          const maxImgSize = 52;
          const drawSize = minImgSize + normalized * (maxImgSize - minImgSize);

          const alpha = 0.15 + 0.85 * normalized;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.drawImage(img, x - drawSize / 2, y - drawSize / 2, drawSize, drawSize);
          ctx.restore();
        }
      }
    }

    const particles = [];
    const PARTICLE_COUNT = 6000;
    for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(new Particle(i));

    let lastTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      drawBackground();

      const maxZoom = 5;
      zoom += 0.004 * (1 + zoom / maxZoom);
      zoom = Math.min(zoom, maxZoom);

      window.parent.postMessage({ type: 'zoomUpdate', zoom: zoom }, '*');

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.scale(zoom, zoom);
      ctx.translate(-centerX, -centerY);

      const gradient = ctx.createRadialGradient(centerX, centerY, blackHoleRadius * 0.5, centerX, centerY, blackHoleRadius * 1.5);
      gradient.addColorStop(0, 'rgba(255,255,200,0.8)');
      gradient.addColorStop(0.5, 'rgba(255,255,200,0.3)');
      gradient.addColorStop(1, 'rgba(255,255,200,0)');
      ctx.beginPath();
      ctx.arc(centerX, centerY, blackHoleRadius * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(centerX, centerY, blackHoleRadius, 0, Math.PI * 2);
      ctx.fillStyle = 'black';
      ctx.fill();

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.update(dt);
        p.draw();
      }

      ctx.restore();
    }

    loadImages().then(() => {
      lastTime = performance.now();
      animate();
    }).catch(() => {
      lastTime = performance.now();
      animate();
    });

    setTimeout(() => {
      if (!imagesLoaded) {
        lastTime = performance.now();
        animate();
      }
    }, 1000);

  </script>
</body>
</html>