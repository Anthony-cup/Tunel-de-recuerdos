<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>V贸rtice de Anillos Giratorios v1</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Parisienne&family=Orbitron:wght@400;700&display=swap');
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #0f1a2e 0%, #000000 100%);
      font-family: 'Orbitron', sans-serif;
    }
    canvas {
      display: none;
      width: 100vw;
      height: 100vh;
      filter: brightness(1.4) contrast(1.5) saturate(1.7);
      touch-action: none;
    }
    #blackHoleFrame, #doorFrame {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
      transition: opacity 0.5s ease-in-out, filter 0.2s;
    }
    #blackHoleFrame {
      z-index: 2;
    }
    #doorFrame {
      z-index: 3;
      display: none;
    }
    #doorFrame.show {
      filter: url(#glitch);
    }
    svg {
      position: absolute;
      width: 0;
      height: 0;
    }
    #errorMessage {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(0.9rem, 3.5vw, 1.2rem);
      text-align: center;
      color: #ff4081;
      text-shadow: 0 0 8px #ff4081, 0 0 16px #ff4081;
      z-index: 10;
      padding: clamp(8px, 2vw, 12px);
      max-width: 85vw;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      line-height: 1.4;
      box-sizing: border-box;
    }
    #gifOverlay {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 5;
      text-align: center;
    }
    #gifOverlay img {
      max-width: 50vw;
      max-height: 50vh;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }
    #gifText {
      position: absolute;
      bottom: -50px;
      left: 50%;
      transform: translateX(-50%);
      color: #ffccff;
      font-family: 'Parisienne', cursive;
      font-size: clamp(1.2rem, 4.5vw, 1.8rem);
      text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4, 0 0 30px #ff69b4;
      background: rgba(0, 0, 0, 0.8);
      padding: 12px 24px;
      border-radius: 12px;
      border: 2px solid #ff69b4;
      cursor: pointer;
      white-space: nowrap;
      transition: background 0.3s, transform 0.3s, box-shadow 0.3s;
    }
    #gifText:hover {
      background: rgba(0, 0, 0, 0.95);
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 0 15px #ff69b4;
    }
    @media (max-width: 720px) {
      #errorMessage {
        font-size: clamp(0.8rem, 3vw, 1rem);
        padding: clamp(6px, 1.5vw, 10px);
        max-width: 90vw;
      }
      canvas {
        filter: brightness(1.2) contrast(1.3) saturate(1.5);
      }
      #gifOverlay img {
        max-width: 80vw;
        max-height: 40vh;
      }
      #gifText {
        font-size: clamp(1rem, 3.5vw, 1.4rem);
        padding: 10px 18px;
        bottom: -40px;
      }
    }
    @media (min-resolution: 2dppx) {
      canvas {
        width: 100vw !important;
        height: 100vh !important;
      }
    }
    #playOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at center, #0f1a2e 0%, #000000 100%);
      z-index: 100;
    }
    #playButton {
      padding: 20px 40px;
      font-size: 2rem;
      font-family: 'Orbitron', sans-serif;
      color: #ffffff;
      background: #ff4081;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      text-shadow: 0 0 10px #ffffff;
      box-shadow: 0 0 20px #ff4081;
      transition: transform 0.3s, background 0.3s;
    }
    #playButton:hover {
      transform: scale(1.1);
      background: #ff80ab;
    }
  </style>
  <svg>
    <filter id="glitch">
      <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"/>
      <feOffset dx="2" dy="0" result="offset"/>
      <feColorMatrix type="matrix" in="offset" values="1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0"/>
      <feBlend mode="screen"/>
    </filter>
  </svg>
</head>
<body>
  <div id="playOverlay">
    <button id="playButton">Play</button>
  </div>
  <div id="errorMessage">No creaste tu proyecto. Por favor, crea tu ling primero.</div>
  <canvas id="tunnelCanvas"></canvas>
  <iframe id="blackHoleFrame"></iframe>
  <iframe id="doorFrame"></iframe>
  <div id="gifOverlay">
    <img id="gifImage" src="" alt="Overlay GIF" />
    <div id="gifText"></div>
  </div>
  <video id="bgMusic" src="mus/1.mp4" style="display: none;" loop></video>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js';
    import { getDatabase, ref, get, set } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js';
    const playOverlay = document.getElementById('playOverlay');
    const playButton = document.getElementById('playButton');
    const bgMusic = document.getElementById('bgMusic');
    const tunnelCanvas = document.getElementById('tunnelCanvas');
    const blackHoleFrame = document.getElementById('blackHoleFrame');
    const doorFrame = document.getElementById('doorFrame');
    const errorMessage = document.getElementById('errorMessage');
    const gifOverlay = document.getElementById('gifOverlay');
    playButton.addEventListener('click', () => {
      playOverlay.style.display = 'none';
      tunnelCanvas.style.display = 'block';
      blackHoleFrame.style.display = 'block';
      blackHoleFrame.src = 'negro.html';
      doorFrame.style.display = 'none';
      errorMessage.style.display = 'none';
      gifOverlay.style.display = 'none';
      bgMusic.play();
      init();
    });
    async function init() {
      const firebaseConfig = {
        apiKey: "AIzaSyBk2SVaP1w4V3MWrpp1r3X5Xk9eH06gBt4",
        authDomain: "tunel-de-recuerdos.firebaseapp.com",
        projectId: "tunel-de-recuerdos",
        storageBucket: "tunel-de-recuerdos.firebasestorage.app",
        messagingSenderId: "630660710506",
        appId: "1:630660710506:web:90d34150c9f21f668eca13",
        measurementId: "G-ETFDVEHML1"
      };
      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);
      function generateUniqueId() {
        return 'id_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now().toString(36);
      }
      async function initializeUser(userId) {
        try {
          const userRef = ref(database, `usuarios/${userId}`);
          const snapshot = await get(userRef);
          if (!snapshot.exists()) {
            console.log(`Creando nuevo usuario con ID: ${userId}`);
            await set(userRef, {
              puerta1Fotos: [],
              puerta2Fotos: [],
              puerta3Fotos: [],
              puerta4Fotos: [],
              puerta5Fotos: [],
              puerta1Anio: "2000",
              puerta2Anio: "2001",
              puerta3Anio: "2002",
              puerta4Anio: "2003",
              puerta5Anio: "2004",
              name1: "Antony",
              name2: "Amigo"
            });
            console.log(`Usuario ${userId} inicializado en Firebase.`);
          }
          return true;
        } catch (error) {
          console.error("Error al inicializar usuario en Firebase:", error);
          return false;
        }
      }
      async function fetchDoorTitlesAndNames() {
        const urlParams = new URLSearchParams(window.location.search);
        let userId = urlParams.get('id')?.trim();
        if (!userId) {
          console.log("No se encontr贸 'id' en la URL, generando uno nuevo.");
          userId = generateUniqueId();
          window.history.replaceState({}, '', `?id=${userId}`);
        }
        console.log("ID utilizado:", userId);
        const initSuccess = await initializeUser(userId);
        if (!initSuccess) {
          errorMessage.textContent = 'Error al inicializar el proyecto. Intenta de nuevo.';
          errorMessage.style.display = 'block';
          return { userId: null, titles: null, name1: null, name2: null };
        }
        try {
          const snapshot = await get(ref(database, `usuarios/${userId}`));
          if (snapshot.exists()) {
            const data = snapshot.val();
            const titles = [
              data.puerta1Anio || "2000",
              data.puerta2Anio || "2001",
              data.puerta3Anio || "2002",
              data.puerta4Anio || "2003",
              data.puerta5Anio || "2004"
            ];
            const name1 = data.name1 || "Antony";
            const name2 = data.name2 || "Amigo";
            console.log("Datos obtenidos de Firebase:", { titles, name1, name2 });
            return { userId, titles, name1, name2 };
          } else {
            console.error(`No se encontraron datos para el usuario ${userId}.`);
            errorMessage.style.display = 'block';
            return { userId: null, titles: null, name1: null, name2: null };
          }
        } catch (error) {
          console.error("Error al obtener datos de Firebase:", error);
          errorMessage.textContent = 'Error al cargar los datos. Por favor, intenta de nuevo.';
          errorMessage.style.display = 'block';
          return { userId: null, titles: null, name1: null, name2: null };
        }
      }
      const result = await fetchDoorTitlesAndNames();
      if (!result.userId || !result.titles) {
        console.error("No se puede continuar sin un ID v谩lido o datos en Firebase.");
        return;
      }
      const { userId, titles: doorTitles, name1, name2 } = result;
      const gifImage = document.getElementById('gifImage');
      const gifText = document.getElementById('gifText');
      let gifState = 'initial';
      const renderer = new THREE.WebGLRenderer({ canvas: tunnelCanvas, alpha: true, antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1.5, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 20000);
      camera.position.set(0, 0, 1000); // Start further back for smooth zoom
      const tunnelRadius = 250;
      const tunnelLength = 20000;
      const ringsCount = 200;
      const particlesPerRing = 220;
      const totalPoints = ringsCount * particlesPerRing;
      const ringSpacing = tunnelLength / ringsCount;
      const posArr = new Float32Array(totalPoints * 3);
      const sizeArr = new Float32Array(totalPoints);
      const alphaArr = new Float32Array(totalPoints);
      const colorArr = new Float32Array(totalPoints * 3);
      const ringBaseZ = new Float32Array(ringsCount);
      const ringRotation = new Float32Array(ringsCount);
      const ringBaseRadius = new Float32Array(ringsCount);
      for (let r = 0; r < ringsCount; r++) {
        ringBaseZ[r] = - (r * ringSpacing) - 200;
        ringRotation[r] = 0;
        ringBaseRadius[r] = tunnelRadius * 0.9;
        for (let j = 0; j < particlesPerRing; j++) {
          const idx = r * particlesPerRing + j;
          const ang = (j / particlesPerRing) * Math.PI * 2;
          const rad = ringBaseRadius[r];
          posArr[idx * 3] = Math.cos(ang) * rad;
          posArr[idx * 3 + 1] = Math.sin(ang) * rad;
          posArr[idx * 3 + 2] = ringBaseZ[r];
          sizeArr[idx] = 2.0 + Math.random() * 4.5;
          alphaArr[idx] = 0.8;
          const hue = (0.7 + 0.3 * Math.cos(r * 0.05 + j * 0.1)) % 1.0;
          const col = new THREE.Color().setHSL(hue, 1.0, 0.8);
          colorArr[idx * 3] = col.r;
          colorArr[idx * 3 + 1] = col.g;
          colorArr[idx * 3 + 2] = col.b;
        }
      }
      const pointsGeo = new THREE.BufferGeometry();
      pointsGeo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
      pointsGeo.setAttribute('size', new THREE.BufferAttribute(sizeArr, 1));
      pointsGeo.setAttribute('alpha', new THREE.BufferAttribute(alphaArr, 1));
      pointsGeo.setAttribute('color', new THREE.BufferAttribute(colorArr, 3));
      const pointsMat = new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        uniforms: {
          uTime: { value: 0.0 },
          uCamZ: { value: camera.position.z }
        },
        vertexShader: `
          attribute float size;
          attribute float alpha;
          attribute vec3 color;
          varying float vAlpha;
          varying vec3 vColor;
          uniform float uTime;
          uniform float uCamZ;
          void main(){
            vAlpha = alpha;
            vColor = color;
            vec3 pos = position;
            float ang = atan(position.y, position.x) + uTime * 0.3;
            pos.x = cos(ang) * length(position.xy);
            pos.y = sin(ang) * length(position.xy);
            vec4 mv = modelViewMatrix * vec4(pos, 1.0);
            float scale = 300.0 / max(1.0, -mv.z);
            gl_PointSize = clamp(size * scale * 2.0, 1.0, 600.0);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          varying vec3 vColor;
          void main(){
            vec2 p = gl_PointCoord - vec2(0.5);
            float d = length(p);
            float o = smoothstep(0.5, 0.0, d);
            gl_FragColor = vec4(vColor, o * vAlpha);
          }
        `
      });
      const points = new THREE.Points(pointsGeo, pointsMat);
      scene.add(points);
      const doorPosition = -(15 * ringSpacing) - 200;
      const doorColors = [0x26c6da, 0xff4081, 0x00e676, 0xab47bc, 0xff9100, 0x3f51b5];
      const emojiList = ['┓', 'グ', ''];
      const rainCount = 50;
      const rainParticles = [];
      const heartShape = new THREE.Shape();
      heartShape.moveTo(0, 0);
      heartShape.bezierCurveTo(0, -0.4, -0.7, -0.6, -0.7, 0);
      heartShape.bezierCurveTo(-0.7, 0.6, 0, 1.2, 0, 1.2);
      heartShape.bezierCurveTo(0, 1.2, 0.7, 0.6, 0.7, 0);
      heartShape.bezierCurveTo(0.7, -0.6, 0, -0.4, 0, 0);
      const heartGeo = new THREE.ExtrudeGeometry(heartShape, { depth: 0.1, bevelEnabled: false });
      heartGeo.scale(tunnelRadius * 0.05, tunnelRadius * 0.05, tunnelRadius * 0.05);
      for (let i = 0; i < rainCount; i++) {
        let particle;
        const type = Math.floor(Math.random() * 4);
        if (type < 3) {
          const emojiCanvas = document.createElement('canvas');
          emojiCanvas.width = 128;
          emojiCanvas.height = 128;
          const ctx = emojiCanvas.getContext('2d');
          ctx.fillStyle = '#' + doorColors[0].toString(16).padStart(6, '0');
          ctx.font = '64px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(emojiList[type], 64, 64);
          const texture = new THREE.CanvasTexture(emojiCanvas);
          const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
          const geo = new THREE.PlaneGeometry(tunnelRadius * 0.1, tunnelRadius * 0.1);
          particle = new THREE.Mesh(geo, material);
        } else {
          const material = new THREE.MeshBasicMaterial({ color: doorColors[0], transparent: true });
          particle = new THREE.Mesh(heartGeo, material);
        }
        particle.position.set(
          (Math.random() - 0.5) * tunnelRadius * 1.8,
          tunnelRadius * 1.2,
          doorPosition + (Math.random() - 0.5) * tunnelRadius * 0.5
        );
        particle.userData = {
          velocity: -tunnelRadius * (0.4 + Math.random() * 0.2),
          startTime: Math.random() * 2,
          type: type
        };
        particle.visible = false;
        scene.add(particle);
        rainParticles.push(particle);
      }
      const doors = [];
      const labelMeshes = [];
      const buttonMeshes = [];
      const buttonTextMeshes = [];
      const buttonLights = [];
      const buttonEdges = [];
      for (let i = 0; i < doorTitles.length; i++) {
        const doorGeo = new THREE.TorusGeometry(tunnelRadius * 0.9, 10, 16, 64);
        const doorMat = new THREE.MeshStandardMaterial({
          color: doorColors[i],
          metalness: 0.9,
          roughness: 0.1,
          emissive: doorColors[i],
          emissiveIntensity: 0.7
        });
        const door = new THREE.Mesh(doorGeo, doorMat);
        door.position.set(0, 0, doorPosition);
        door.visible = i === 0;
        scene.add(door);
        doors.push(door);
        const edgeGeo = new THREE.TorusGeometry(tunnelRadius * 0.95, 2, 8, 64);
        const edgeMat = new THREE.MeshBasicMaterial({
          color: doorColors[i],
          transparent: true,
          opacity: 0.95,
          blending: THREE.AdditiveBlending
        });
        const edge = new THREE.Mesh(edgeGeo, edgeMat);
        edge.position.set(0, 0, doorPosition);
        edge.visible = i === 0;
        scene.add(edge);
        const labelCanvas = document.createElement('canvas');
        labelCanvas.width = 1024;
        labelCanvas.height = 512;
        const labelCtx = labelCanvas.getContext('2d');
        labelCtx.clearRect(0, 0, 1024, 512);
        labelCtx.fillStyle = '#ffccff';
        labelCtx.font = 'bold 150px Parisienne';
        labelCtx.textAlign = 'center';
        labelCtx.textBaseline = 'middle';
        labelCtx.shadowColor = '#' + doorColors[i].toString(16).padStart(6, '0');
        labelCtx.shadowBlur = 50;
        labelCtx.fillText(doorTitles[i], 512, 256);
        const labelTexture = new THREE.CanvasTexture(labelCanvas);
        const labelMaterial = new THREE.MeshBasicMaterial({
          map: labelTexture,
          transparent: true,
          side: THREE.DoubleSide
        });
        const labelGeometry = new THREE.PlaneGeometry(tunnelRadius * 0.5, tunnelRadius * 0.25);
        const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
        labelMesh.position.set(0, tunnelRadius * 0.15, doorPosition - 1);
        labelMesh.visible = i === 0;
        labelMesh.userData = { baseOpacity: 1.0 };
        scene.add(labelMesh);
        labelMeshes.push(labelMesh);
        const heartShape = new THREE.Shape();
        heartShape.moveTo(0, 0);
        heartShape.bezierCurveTo(0, -0.4, -0.7, -0.6, -0.7, 0);
        heartShape.bezierCurveTo(-0.7, 0.6, 0, 1.2, 0, 1.2);
        heartShape.bezierCurveTo(0, 1.2, 0.7, 0.6, 0.7, 0);
        heartShape.bezierCurveTo(0.7, -0.6, 0, -0.4, 0, 0);
        const extrudeSettings = { depth: 0.3, bevelEnabled: true, bevelSegments: 8, steps: 2, bevelSize: 0.15, bevelThickness: 0.15 };
        const buttonGeo = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
        buttonGeo.scale(tunnelRadius * 0.09, tunnelRadius * 0.09, tunnelRadius * 0.09);
        const buttonMat = new THREE.MeshStandardMaterial({
          color: doorColors[i],
          emissive: doorColors[i],
          emissiveIntensity: 0.8,
          metalness: 0.9,
          roughness: 0.1
        });
        const buttonMesh = new THREE.Mesh(buttonGeo, buttonMat);
        buttonMesh.position.set(0, -tunnelRadius * 0.15, doorPosition - 0.1);
        buttonMesh.rotation.z = Math.PI;
        buttonMesh.visible = i === 0;
        buttonMesh.userData = { doorIndex: i, baseColor: doorColors[i] };
        scene.add(buttonMesh);
        const buttonEdgeGeo = new THREE.EdgesGeometry(buttonGeo);
        const buttonEdgeMat = new THREE.LineBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 1.0
        });
        const buttonEdge = new THREE.LineSegments(buttonEdgeGeo, buttonEdgeMat);
        buttonEdge.position.copy(buttonMesh.position);
        buttonEdge.rotation.z = Math.PI;
        buttonEdge.visible = i === 0;
        scene.add(buttonEdge);
        const buttonLight = new THREE.PointLight(doorColors[i], 1.5, tunnelRadius * 0.5);
        buttonLight.position.set(0, -tunnelRadius * 0.15, doorPosition - 0.1);
        buttonLight.visible = i === 0;
        scene.add(buttonLight);
        const buttonTextCanvas = document.createElement('canvas');
        buttonTextCanvas.width = 256;
        buttonTextCanvas.height = 128;
        const btnCtx = buttonTextCanvas.getContext('2d');
        btnCtx.fillStyle = '#' + doorColors[i].toString(16).padStart(6, '0');
        btnCtx.fillRect(0, 0, 256, 128);
        btnCtx.fillStyle = '#ffccff';
        btnCtx.font = 'bold 48px Parisienne';
        btnCtx.textAlign = 'center';
        btnCtx.textBaseline = 'middle';
        btnCtx.shadowColor = '#ffffff';
        btnCtx.shadowBlur = 20;
        btnCtx.fillText('Iniciar', 128, 64);
        const buttonTextTexture = new THREE.CanvasTexture(buttonTextCanvas);
        const buttonTextMat = new THREE.MeshBasicMaterial({
          map: buttonTextTexture,
          transparent: true,
          side: THREE.DoubleSide
        });
        const buttonTextGeo = new THREE.PlaneGeometry(tunnelRadius * 0.2, tunnelRadius * 0.1);
        const buttonTextMesh = new THREE.Mesh(buttonTextGeo, buttonTextMat);
        buttonTextMesh.position.set(0, -tunnelRadius * 0.25, doorPosition - 0.05);
        buttonTextMesh.rotation.z = Math.PI;
        buttonTextMesh.visible = false;
        buttonTextMesh.userData = { doorIndex: i };
        scene.add(buttonTextMesh);
        buttonMeshes.push(buttonMesh);
        buttonTextMeshes.push(buttonTextMesh);
        buttonLights.push(buttonLight);
        buttonEdges.push(buttonEdge);
      }
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
      directionalLight.position.set(0, 100, doorPosition - 50);
      scene.add(directionalLight);
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let lastHoveredButton = null;
      window.addEventListener('mousemove', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(buttonMeshes, true);
        if (lastHoveredButton) {
          const idx = lastHoveredButton.userData.doorIndex;
          buttonMeshes[idx].material.emissiveIntensity = 0.8;
          buttonTextMeshes[idx].visible = false;
          doors[idx].material.emissiveIntensity = 0.7;
          buttonLights[idx].intensity = 1.5;
        }
        if (intersects.length > 0 && intersects[0].object.visible) {
          lastHoveredButton = intersects[0].object;
          const idx = lastHoveredButton.userData.doorIndex;
          buttonMeshes[idx].material.emissiveIntensity = 1.3;
          buttonTextMeshes[idx].visible = true;
          doors[idx].material.emissiveIntensity = 1.0;
          buttonLights[idx].intensity = 2.0;
        } else {
          lastHoveredButton = null;
        }
      });
      gifText.addEventListener('click', () => {
        if (gifState === 'initial' && currentDoorIndex === 0) {
          gifState = 'second';
          gifImage.src = 'https://media.tenor.com/CNJSyzMIkskAAAAj/bubu-dudu-sseeyall.gif';
          gifText.innerHTML = `Esto te lo dedico para ti ${name2}.<br><br>Aqu铆 va nuestra vida que vivimos.`;
          console.log('Clic en primer texto, mostrando segundo GIF y texto');
        } else if (gifState === 'second' && currentDoorIndex === 0) {
          gifState = 'done';
          gifOverlay.style.display = 'none';
          console.log('Clic en segundo texto, ocultando GIF y texto');
        }
      });
      window.addEventListener('click', (event) => {
        if (gifState !== 'done' && currentDoorIndex === 0) {
          return; // Prevent door clicks while GIF sequence is active
        }
        console.log(`Clic detectado en coordenadas: x=${event.clientX}, y=${event.clientY}`);
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        console.log(`Coordenadas normalizadas: x=${mouse.x}, y=${mouse.y}`);
        console.log(`Puerta actual: ${doorTitles[currentDoorIndex]}, visible: ${doors[currentDoorIndex].visible}, bot贸n visible: ${buttonMeshes[currentDoorIndex].visible}`);
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(buttonMeshes[currentDoorIndex], true);
        console.log(`Intersecciones con bot贸n de ${doorTitles[currentDoorIndex]}: ${intersects.length}`, intersects.map(i => ({
          doorIndex: i.object.userData.doorIndex,
          door: doorTitles[i.object.userData.doorIndex],
          visible: i.object.visible
        })));
        if (intersects.length > 0 && intersects[0].object.visible) {
          const doorIndex = intersects[0].object.userData.doorIndex;
          console.log(`Bot贸n clicado para puerta: ${doorTitles[doorIndex]}`);
          try {
            doorFrame.src = `puerta${doorIndex + 1}.html?id=${userId}`;
            doorFrame.style.display = 'block';
            doorFrame.style.opacity = '1';
            doorFrame.classList.add('show');
            setTimeout(() => doorFrame.classList.remove('show'), 200);
            doors[doorIndex].visible = false;
            labelMeshes[doorIndex].visible = false;
            buttonMeshes[doorIndex].visible = false;
            buttonTextMeshes[doorIndex].visible = false;
            buttonLights[doorIndex].visible = false;
            buttonEdges[doorIndex].visible = false;
            rainParticles.forEach(p => p.visible = false);
            doors[doorIndex].material.emissiveIntensity = 1.5;
            setTimeout(() => {
              doors[doorIndex].material.emissiveIntensity = 0.7;
            }, 200);
            doorStates[doorIndex].opened = true;
            console.log(`Cargando panel: puerta${doorIndex + 1}.html?id=${userId}`);
          } catch (error) {
            console.error(`Error al cargar puerta${doorIndex + 1}.html?id=${userId}:`, error);
          }
        } else {
          console.warn(`No se detect贸 el bot贸n de ${doorTitles[currentDoorIndex]} o no est谩 visible`);
        }
      });
      doorFrame.onerror = () => {
        console.error(`Error al cargar el iframe: ${doorFrame.src}`);
      };
      let timeElapsed = 0;
      let panelHidden = false;
      let isStopped = false;
      let isResetting = false;
      let resetStartTime = 0;
      let currentDoorIndex = 0;
      const doorStates = doorTitles.map(() => ({ z: doorPosition, opened: false }));
      let zoomStartTime = 0;
      let zoomDuration = 3; // Duration of initial zoom in seconds
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
      window.addEventListener('message', (event) => {
        console.log('Mensaje recibido:', event.data);
        if (event.data.type === 'zoomUpdate') {
          console.log(`Mensaje zoomUpdate recibido: zoom=${event.data.zoom}`);
          const zoom = event.data.zoom;
          const entryZoom = 1.2;
          const maxZoom = 5.0;
          let frac = zoom > entryZoom ? Math.min(1, (zoom - entryZoom) / (maxZoom - entryZoom)) : 0;
          blackHoleFrame.style.opacity = 1 - frac;
          if (zoom >= 4.9 && !panelHidden) {
            blackHoleFrame.style.display = 'none';
            panelHidden = true;
            doors[0].visible = true;
            labelMeshes[0].visible = true;
            buttonMeshes[0].visible = true;
            buttonTextMeshes[0].visible = false;
            buttonLights[0].visible = true;
            buttonEdges[0].visible = true;
            rainParticles.forEach((p, i) => {
              p.visible = true;
              p.material.color.set(doorColors[0]);
              if (p.userData.type < 3) {
                const ctx = p.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, 128, 128);
                ctx.fillStyle = '#' + doorColors[0].toString(16).padStart(6, '0');
                ctx.font = '64px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emojiList[p.userData.type], 64, 64);
                p.material.map.needsUpdate = true;
              }
            });
            isStopped = false;
            if (gifState === 'initial' && currentDoorIndex === 0) {
              gifImage.src = 'https://i.pinimg.com/originals/fa/e6/95/fae695d4556f98aca6709361dcce9273.gif';
              gifText.textContent = `Hola soy ${name1}`;
              gifOverlay.style.display = 'block';
              console.log('Mostrando primer GIF y texto');
            }
            console.log(`Panel inicial oculto, mostrando puerta: ${doorTitles[0]}`);
          }
        } else if (event.data.type === 'doorClosed') {
          console.log(`Mensaje doorClosed recibido, puerta actual: ${doorTitles[currentDoorIndex]}`);
          if (currentDoorIndex < doorTitles.length - 1) {
            isResetting = true;
            resetStartTime = timeElapsed;
            doorFrame.style.opacity = '1';
            currentDoorIndex = Math.min(currentDoorIndex + 1, doorTitles.length - 1);
            console.log(`Preparando siguiente puerta: ${doorTitles[currentDoorIndex]}`);
            doors.forEach((door, i) => {
              door.visible = i === currentDoorIndex;
              labelMeshes[i].visible = i === currentDoorIndex;
              buttonMeshes[i].visible = i === currentDoorIndex;
              buttonTextMeshes[i].visible = false;
              buttonLights[i].visible = i === currentDoorIndex;
              buttonEdges[i].visible = i === currentDoorIndex;
            });
            rainParticles.forEach((p, i) => {
              p.visible = i === currentDoorIndex;
              p.position.set(
                (Math.random() - 0.5) * tunnelRadius * 1.8,
                tunnelRadius * 1.2,
                doorPosition + (Math.random() - 0.5) * tunnelRadius * 0.5
              );
              p.material.color.set(doorColors[currentDoorIndex]);
              if (p.userData.type < 3) {
                const ctx = p.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, 128, 128);
                ctx.fillStyle = '#' + doorColors[currentDoorIndex].toString(16).padStart(6, '0');
                ctx.font = '64px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emojiList[p.userData.type], 64, 64);
                p.material.map.needsUpdate = true;
              }
            });
            setTimeout(() => {
              labelMeshes[currentDoorIndex].material.opacity = 1.0;
            }, 500);
          } else {
            doorFrame.style.opacity = '0';
            rainParticles.forEach(p => p.visible = false);
            setTimeout(() => {
              doorFrame.style.display = 'none';
              doorFrame.src = '';
              console.log('ltima puerta cerrada, ocultando panel');
            }, 500);
          }
        }
      });
      let last = performance.now();
      function render() {
        requestAnimationFrame(render);
        const now = performance.now();
        const dt = (now - last) / 1000;
        last = now;
        timeElapsed += dt;
        if (!panelHidden && !isResetting && timeElapsed < zoomDuration) {
          const zoomProgress = timeElapsed / zoomDuration;
          const easedProgress = 1 - Math.pow(1 - zoomProgress, 3); // Ease-out cubic
          camera.position.z = 1000 + (doorPosition + 200 - 1000) * easedProgress;
        }
        if (timeElapsed > 10 && !panelHidden) {
          blackHoleFrame.style.opacity = 0;
          setTimeout(() => {
            blackHoleFrame.style.display = 'none';
            panelHidden = true;
            doors[0].visible = true;
            labelMeshes[0].visible = true;
            buttonMeshes[0].visible = true;
            buttonTextMeshes[0].visible = false;
            buttonLights[0].visible = true;
            buttonEdges[0].visible = true;
            rainParticles.forEach(p => p.visible = true);
            isStopped = false;
            if (gifState === 'initial' && currentDoorIndex === 0) {
              gifImage.src = 'https://i.pinimg.com/originals/fa/e6/95/fae695d4556f98aca6709361dcce9273.gif';
              gifText.textContent = `Hola soy ${name1}`;
              gifOverlay.style.display = 'block';
              console.log('Mostrando primer GIF y texto (timeout)');
            }
            console.log(`Mostrando puerta inicial: ${doorTitles[0]}`);
          }, 500);
        }
        if (isResetting) {
          const resetDuration = 0.5;
          const resetProgress = Math.min((timeElapsed - resetStartTime) / resetDuration, 1);
          camera.position.z = (doorPosition + 200) + (30 - (doorPosition + 200)) * resetProgress;
          if (resetProgress >= 1) {
            isResetting = false;
            doorFrame.style.opacity = '0';
            setTimeout(() => {
              doorFrame.style.display = 'none';
              doorFrame.src = '';
              if (currentDoorIndex < doorTitles.length) {
                doors.forEach((door, i) => {
                  door.visible = i === currentDoorIndex;
                  labelMeshes[i].visible = i === currentDoorIndex;
                  labelMeshes[i].material.opacity = 0.5;
                  buttonMeshes[i].visible = i === currentDoorIndex;
                  buttonTextMeshes[i].visible = false;
                  buttonLights[i].visible = i === currentDoorIndex;
                  buttonEdges[i].visible = i === currentDoorIndex;
                });
                rainParticles.forEach((p, i) => {
                  p.visible = i === currentDoorIndex;
                  p.position.set(
                    (Math.random() - 0.5) * tunnelRadius * 1.8,
                    tunnelRadius * 1.2,
                    doorPosition + (Math.random() - 0.5) * tunnelRadius * 0.5
                  );
                  p.material.color.set(doorColors[currentDoorIndex]);
                  if (p.userData.type < 3) {
                    const ctx = p.material.map.image.getContext('2d');
                    ctx.clearRect(0, 0, 128, 128);
                    ctx.fillStyle = '#' + doorColors[currentDoorIndex].toString(16).padStart(6, '0');
                    ctx.font = '64px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(emojiList[p.userData.type], 64, 64);
                    p.material.map.needsUpdate = true;
                  }
                });
                isStopped = false;
                console.log(`Mostrando puerta: ${doorTitles[currentDoorIndex]}, posici贸n z: ${camera.position.z}`);
                setTimeout(() => {
                  labelMeshes[currentDoorIndex].material.opacity = 1.0;
                }, 500);
              }
            }, 500);
          }
        }
        if (panelHidden && !isStopped && !isResetting && currentDoorIndex < doorStates.length && !doorStates[currentDoorIndex].opened) {
          const targetZ = doorStates[currentDoorIndex].z + 200;
          camera.position.z += (targetZ - camera.position.z) * 0.02 * dt * 60;
          if (Math.abs(targetZ - camera.position.z) < 10) {
            isStopped = true;
            console.log(`Zoom completado para puerta: ${doorTitles[currentDoorIndex]}, posici贸n z: ${camera.position.z}`);
          }
        }
        rainParticles.forEach(p => {
          if (p.visible && timeElapsed > p.userData.startTime) {
            p.position.y += p.userData.velocity * dt;
            if (p.position.y < -tunnelRadius * 1.2) {
              p.position.y = tunnelRadius * 1.2;
              p.position.x = (Math.random() - 0.5) * tunnelRadius * 1.8;
              p.position.z = doorPosition + (Math.random() - 0.5) * tunnelRadius * 0.5;
              p.userData.startTime = timeElapsed + Math.random() * 2;
            }
            p.rotation.z += 0.5 * dt;
          }
        });
        pointsMat.uniforms.uTime.value = now * 0.001;
        buttonMeshes.forEach((mesh, i) => {
          mesh.position.y = -tunnelRadius * 0.15 + Math.sin(now * 0.001) * tunnelRadius * 0.015;
          buttonLights[i].position.y = mesh.position.y;
          buttonEdges[i].position.y = mesh.position.y;
        });
        labelMeshes.forEach((mesh) => {
          mesh.position.y = tunnelRadius * 0.15 + Math.sin(now * 0.001) * tunnelRadius * 0.02;
        });
        renderer.render(scene, camera);
      }
      render();
    }
  </script>
</body>
</html>
