<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>V贸rtice de Anillos Giratorios v2</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #0f1a2e 0%, #000000 100%);
      font-family: 'Orbitron', sans-serif;
      color: #ffffff;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100vh;
      filter: brightness(1.4) contrast(1.5) saturate(1.7);
    }
    #blackHoleFrame, #doorFrame {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
      transition: opacity 0.5s ease-in-out, filter 0.2s;
      object-fit: contain;
    }
    #blackHoleFrame {
      z-index: 2;
    }
    #doorFrame {
      z-index: 3;
      display: none;
    }
    #doorFrame.show {
      filter: url(#glitch);
    }
    svg {
      position: absolute;
      width: 0;
      height: 0;
    }
    #errorMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(1rem, 4vw, 1.5rem);
      text-align: center;
      color: #ff4081;
      text-shadow: 0 0 8px #ff4081, 0 0 16px #ff4081;
      z-index: 10;
      display: none;
      padding: 10px;
      max-width: 90%;
    }
    @media (max-width: 768px) {
      canvas {
        filter: brightness(1.2) contrast(1.3) saturate(1.5);
      }
      #errorMessage {
        font-size: clamp(0.9rem, 3.5vw, 1.2rem);
        text-shadow: 0 0 6px #ff4081, 0 0 12px #ff4081;
      }
      #blackHoleFrame, #doorFrame {
        height: 100vh;
      }
    }
  </style>
  <svg>
    <filter id="glitch">
      <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"/>
      <feOffset dx="2" dy="0" result="offset"/>
      <feColorMatrix type="matrix" in="offset" values="1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0"/>
      <feBlend mode="screen"/>
    </filter>
  </svg>
</head>
<body>
  <div id="errorMessage">No creaste tu proyecto. Por favor, crea tu ID primero.</div>
  <canvas id="tunnelCanvas"></canvas>
  <iframe id="blackHoleFrame" src="negro.html"></iframe>
  <iframe id="doorFrame" src=""></iframe>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js';
    import { getDatabase, ref, get } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js';
    const firebaseConfig = {
      apiKey: "AIzaSyBk2SVaP1w4V3MWrpp1r3X5Xk9eH06gBt4",
      authDomain: "tunel-de-recuerdos.firebaseapp.com",
      projectId: "tunel-de-recuerdos",
      storageBucket: "tunel-de-recuerdos.firebasestorage.app",
      messagingSenderId: "630660710506",
      appId: "1:630660710506:web:90d34150c9f21f668eca13",
      measurementId: "G-ETFDVEHML1"
    };
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    async function validateAndFetchDoorTitles() {
      const urlParams = new URLSearchParams(window.location.search);
      const userId = urlParams.get('id')?.trim();
      const errorMessage = document.getElementById('errorMessage');
      const defaultTitles = ["2000", "2001", "2002", "2003", "2004"];
      if (!userId || userId === '') {
        console.error("No se encontr贸 'id' en la URL o es inv谩lido.");
        errorMessage.style.display = 'block';
        return { userId: null, titles: null };
      }
      try {
        console.log(`Consultando Firebase para usuarios/${userId}`);
        const snapshot = await get(ref(database, `usuarios/${userId}`));
        if (snapshot.exists()) {
          const data = snapshot.val();
          const titles = [
            data.puerta1Anio || defaultTitles[0],
            data.puerta2Anio || defaultTitles[1],
            data.puerta3Anio || defaultTitles[2],
            data.puerta4Anio || defaultTitles[3],
            data.puerta5Anio || defaultTitles[4]
          ];
          console.log("T铆tulos obtenidos de Firebase:", titles);
          return { userId, titles };
        } else {
          console.error(`No se encontraron datos para el usuario ${userId}.`);
          errorMessage.style.display = 'block';
          return { userId: null, titles: null };
        }
      } catch (error) {
        console.error("Error al obtener datos de Firebase:", error);
        errorMessage.style.display = 'block';
        return { userId: null, titles: null };
      }
    }
    (async function(){
      const { userId, doorTitles } = await validateAndFetchDoorTitles();
      if (!userId || !doorTitles) {
        console.error("No se puede continuar sin un ID v谩lido o datos en Firebase.");
        return;
      }
      const tunnelCanvas = document.getElementById('tunnelCanvas');
      const blackHoleFrame = document.getElementById('blackHoleFrame');
      const doorFrame = document.getElementById('doorFrame');
      const renderer = new THREE.WebGLRenderer({ canvas: tunnelCanvas, alpha: true, antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      const scene = new THREE.Scene();
      const isMobile = window.innerWidth <= 768;
      const camera = new THREE.PerspectiveCamera(isMobile ? 80 : 70, window.innerWidth/window.innerHeight, 0.1, 20000);
      camera.position.set(0, 0, 30);
      const tunnelRadius = isMobile ? 200 : 250;
      const tunnelLength = 20000;
      const ringsCount = isMobile ? 150 : 200;
      const particlesPerRing = isMobile ? 160 : 220;
      const totalPoints = ringsCount * particlesPerRing;
      const ringSpacing = tunnelLength / ringsCount;
      const posArr = new Float32Array(totalPoints * 3);
      const sizeArr = new Float32Array(totalPoints);
      const alphaArr = new Float32Array(totalPoints);
      const colorArr = new Float32Array(totalPoints * 3);
      const ringBaseZ = new Float32Array(ringsCount);
      const ringRotation = new Float32Array(ringsCount);
      const ringBaseRadius = new Float32Array(ringsCount);
      for (let r = 0; r < ringsCount; r++) {
        ringBaseZ[r] = - (r * ringSpacing) - 200;
        ringRotation[r] = 0;
        ringBaseRadius[r] = tunnelRadius * 0.9;
        for (let j = 0; j < particlesPerRing; j++) {
          const idx = r * particlesPerRing + j;
          const ang = (j / particlesPerRing) * Math.PI * 2;
          const rad = ringBaseRadius[r];
          posArr[idx * 3] = Math.cos(ang) * rad;
          posArr[idx * 3 + 1] = Math.sin(ang) * rad;
          posArr[idx * 3 + 2] = ringBaseZ[r];
          sizeArr[idx] = isMobile ? 1.5 + Math.random() * 3.5 : 2.0 + Math.random() * 4.5;
          alphaArr[idx] = 0.8;
          const hue = (0.7 + 0.3 * Math.cos(r * 0.05 + j * 0.1)) % 1.0;
          const col = new THREE.Color().setHSL(hue, 1.0, 0.8);
          colorArr[idx * 3] = col.r;
          colorArr[idx * 3 + 1] = col.g;
          colorArr[idx * 3 + 2] = col.b;
        }
      }
      const pointsGeo = new THREE.BufferGeometry();
      pointsGeo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
      pointsGeo.setAttribute('size', new THREE.BufferAttribute(sizeArr, 1));
      pointsGeo.setAttribute('alpha', new THREE.BufferAttribute(alphaArr, 1));
      pointsGeo.setAttribute('color', new THREE.BufferAttribute(colorArr, 3));
      const pointsMat = new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        uniforms: {
          uTime: { value: 0.0 },
          uCamZ: { value: camera.position.z }
        },
        vertexShader: `
          attribute float size;
          attribute float alpha;
          attribute vec3 color;
          varying float vAlpha;
          varying vec3 vColor;
          uniform float uTime;
          uniform float uCamZ;
          void main(){
            vAlpha = alpha;
            vColor = color;
            vec3 pos = position;
            float ang = atan(position.y, position.x) + uTime * 0.3;
            pos.x = cos(ang) * length(position.xy);
            pos.y = sin(ang) * length(position.xy);
            vec4 mv = modelViewMatrix * vec4(pos, 1.0);
            float scale = 300.0 / max(1.0, -mv.z);
            gl_PointSize = clamp(size * scale * ${isMobile ? '1.5' : '2.0'}, 1.0, ${isMobile ? '400.0' : '600.0'});
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          varying float vAlpha;
          varying vec3 vColor;
          void main(){
            vec2 p = gl_PointCoord - vec2(0.5);
            float d = length(p);
            float o = smoothstep(0.5, 0.0, d);
            gl_FragColor = vec4(vColor, o * vAlpha);
          }
        `
      });
      const points = new THREE.Points(pointsGeo, pointsMat);
      scene.add(points);
      const doorPosition = -(15 * ringSpacing) - 200;
      const doorColors = [0x26c6da, 0xff4081, 0x00e676, 0xab47bc, 0xff9100];
      const emojiList = ['┓', 'グ', ''];
      const rainCount = isMobile ? 30 : 50;
      const rainParticles = [];
      const heartShape = new THREE.Shape();
      heartShape.moveTo(0, 0);
      heartShape.bezierCurveTo(0, -0.4, -0.7, -0.6, -0.7, 0);
      heartShape.bezierCurveTo(-0.7, 0.6, 0, 1.2, 0, 1.2);
      heartShape.bezierCurveTo(0, 1.2, 0.7, 0.6, 0.7, 0);
      heartShape.bezierCurveTo(0.7, -0.6, 0, -0.4, 0, 0);
      const heartGeo = new THREE.ExtrudeGeometry(heartShape, { depth: 0.1, bevelEnabled: false });
      heartGeo.scale(tunnelRadius * 0.05, tunnelRadius * 0.05, tunnelRadius * 0.05);
      for (let i = 0; i < rainCount; i++) {
        let particle;
        const type = Math.floor(Math.random() * 4);
        if (type < 3) {
          const emojiCanvas = document.createElement('canvas');
          emojiCanvas.width = isMobile ? 96 : 128;
          emojiCanvas.height = isMobile ? 96 : 128;
          const ctx = emojiCanvas.getContext('2d');
          ctx.fillStyle = '#' + doorColors[0].toString(16).padStart(6, '0');
          ctx.font = isMobile ? '48px sans-serif' : '64px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(emojiList[type], isMobile ? 48 : 64, isMobile ? 48 : 64);
          const texture = new THREE.CanvasTexture(emojiCanvas);
          const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
          const geo = new THREE.PlaneGeometry(tunnelRadius * 0.1, tunnelRadius * 0.1);
          particle = new THREE.Mesh(geo, material);
        } else {
          const material = new THREE.MeshBasicMaterial({ color: doorColors[0], transparent: true });
          particle = new THREE.Mesh(heartGeo, material);
        }
        particle.position.set(
          (Math.random() - 0.5) * tunnelRadius * 1.8,
          tunnelRadius * 1.2,
          doorPosition + (Math.random() - 0.5) * tunnelRadius * 0.5
        );
        particle.userData = {
          velocity: -tunnelRadius * (0.4 + Math.random() * 0.2),
          startTime: Math.random() * 2,
          type: type
        };
        particle.visible = false;
        scene.add(particle);
        rainParticles.push(particle);
      }
      const doors = [];
      const labelMeshes = [];
      const buttonMeshes = [];
      const buttonTextMeshes = [];
      const buttonLights = [];
      const buttonEdges = [];
      for (let i = 0; i < doorTitles.length; i++) {
        const doorGeo = new THREE.TorusGeometry(tunnelRadius * 0.9, isMobile ? 8 : 10, 16, 64);
        const doorMat = new THREE.MeshStandardMaterial({
          color: doorColors[i],
          metalness: 0.9,
          roughness: 0.1,
          emissive: doorColors[i],
          emissiveIntensity: 0.7
        });
        const door = new THREE.Mesh(doorGeo, doorMat);
        door.position.set(0, 0, doorPosition);
        door.visible = i === 0;
        scene.add(door);
        doors.push(door);
        const edgeGeo = new THREE.TorusGeometry(tunnelRadius * 0.95, isMobile ? 1.5 : 2, 8, 64);
        const edgeMat = new THREE.MeshBasicMaterial({
          color: doorColors[i],
          transparent: true,
          opacity: 0.95,
          blending: THREE.AdditiveBlending
        });
        const edge = new THREE.Mesh(edgeGeo, edgeMat);
        edge.position.set(0, 0, doorPosition);
        edge.visible = i === 0;
        scene.add(edge);
        const labelCanvas = document.createElement('canvas');
        labelCanvas.width = isMobile ? 768 : 1024;
        labelCanvas.height = isMobile ? 384 : 512;
        const labelCtx = labelCanvas.getContext('2d');
        labelCtx.clearRect(0, 0, labelCanvas.width, labelCanvas.height);
        labelCtx.fillStyle = '#ffffff';
        labelCtx.font = isMobile ? 'bold 120px Orbitron' : 'bold 150px Orbitron';
        labelCtx.textAlign = 'center';
        labelCtx.textBaseline = 'middle';
        labelCtx.shadowColor = '#' + doorColors[i].toString(16).padStart(6, '0');
        labelCtx.shadowBlur = isMobile ? 40 : 50;
        labelCtx.fillText(doorTitles[i], labelCanvas.width / 2, labelCanvas.height / 2);
        const labelTexture = new THREE.CanvasTexture(labelCanvas);
        const labelMaterial = new THREE.MeshBasicMaterial({
          map: labelTexture,
          transparent: true,
          side: THREE.DoubleSide
        });
        const labelGeometry = new THREE.PlaneGeometry(tunnelRadius * 0.5, tunnelRadius * 0.25);
        const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
        labelMesh.position.set(0, tunnelRadius * 0.15, doorPosition - 1);
        labelMesh.visible = i === 0;
        labelMesh.userData = { baseOpacity: 1.0 };
        scene.add(labelMesh);
        labelMeshes.push(labelMesh);
        const heartShape = new THREE.Shape();
        heartShape.moveTo(0, 0);
        heartShape.bezierCurveTo(0, -0.4, -0.7, -0.6, -0.7, 0);
        heartShape.bezierCurveTo(-0.7, 0.6, 0, 1.2, 0, 1.2);
        heartShape.bezierCurveTo(0, 1.2, 0.7, 0.6, 0.7, 0);
        heartShape.bezierCurveTo(0.7, -0.6, 0, -0.4, 0, 0);
        const extrudeSettings = { depth: 0.3, bevelEnabled: true, bevelSegments: 8, steps: 2, bevelSize: 0.15, bevelThickness: 0.15 };
        const buttonGeo = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
        buttonGeo.scale(tunnelRadius * 0.09, tunnelRadius * 0.09, tunnelRadius * 0.09);
        const buttonMat = new THREE.MeshStandardMaterial({
          color: doorColors[i],
          emissive: doorColors[i],
          emissiveIntensity: 0.8,
          metalness: 0.9,
          roughness: 0.1
        });
        const buttonMesh = new THREE.Mesh(buttonGeo, buttonMat);
        buttonMesh.position.set(0, -tunnelRadius * 0.15, doorPosition - 0.1);
        buttonMesh.rotation.z = Math.PI;
        buttonMesh.visible = i === 0;
        buttonMesh.userData = { doorIndex: i, baseColor: doorColors[i] };
        scene.add(buttonMesh);
        const buttonEdgeGeo = new THREE.EdgesGeometry(buttonGeo);
        const buttonEdgeMat = new THREE.LineBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 1.0
        });
        const buttonEdge = new THREE.LineSegments(buttonEdgeGeo, buttonEdgeMat);
        buttonEdge.position.copy(buttonMesh.position);
        buttonEdge.rotation.z = Math.PI;
        buttonEdge.visible = i === 0;
        scene.add(buttonEdge);
        const buttonLight = new THREE.PointLight(doorColors[i], isMobile ? 1.2 : 1.5, tunnelRadius * 0.5);
        buttonLight.position.set(0, -tunnelRadius * 0.15, doorPosition - 0.1);
        buttonLight.visible = i === 0;
        scene.add(buttonLight);
        const buttonTextCanvas = document.createElement('canvas');
        buttonTextCanvas.width = isMobile ? 192 : 256;
        buttonTextCanvas.height = isMobile ? 96 : 128;
        const btnCtx = buttonTextCanvas.getContext('2d');
        btnCtx.fillStyle = '#' + doorColors[i].toString(16).padStart(6, '0');
        btnCtx.fillRect(0, 0, buttonTextCanvas.width, buttonTextCanvas.height);
        btnCtx.fillStyle = '#ffffff';
        btnCtx.font = isMobile ? 'bold 36px Orbitron' : 'bold 48px Orbitron';
        btnCtx.textAlign = 'center';
        btnCtx.textBaseline = 'middle';
        btnCtx.shadowColor = '#ffffff';
        btnCtx.shadowBlur = isMobile ? 15 : 20;
        btnCtx.fillText('Iniciar', buttonTextCanvas.width / 2, buttonTextCanvas.height / 2);
        const buttonTextTexture = new THREE.CanvasTexture(buttonTextCanvas);
        const buttonTextMat = new THREE.MeshBasicMaterial({
          map: buttonTextTexture,
          transparent: true,
          side: THREE.DoubleSide
        });
        const buttonTextGeo = new THREE.PlaneGeometry(tunnelRadius * 0.2, tunnelRadius * 0.1);
        const buttonTextMesh = new THREE.Mesh(buttonTextGeo, buttonTextMat);
        buttonTextMesh.position.set(0, -tunnelRadius * 0.25, doorPosition - 0.05);
        buttonTextMesh.rotation.z = Math.PI;
        buttonTextMesh.visible = false;
        buttonTextMesh.userData = { doorIndex: i };
        scene.add(buttonTextMesh);
        buttonMeshes.push(buttonMesh);
        buttonTextMeshes.push(buttonTextMesh);
        buttonLights.push(buttonLight);
        buttonEdges.push(buttonEdge);
      }
      const ambientLight = new THREE.AmbientLight(0xffffff, isMobile ? 0.6 : 0.7);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, isMobile ? 0.8 : 0.9);
      directionalLight.position.set(0, 100, doorPosition - 50);
      scene.add(directionalLight);
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let lastHoveredButton = null;
      function updateMouseOrTouch(event, isTouch = false) {
        const clientX = isTouch ? event.touches[0].clientX : event.clientX;
        const clientY = isTouch ? event.touches[0].clientY : event.clientY;
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(buttonMeshes, true);
        if (lastHoveredButton) {
          const idx = lastHoveredButton.userData.doorIndex;
          buttonMeshes[idx].material.emissiveIntensity = 0.8;
          buttonTextMeshes[idx].visible = false;
          doors[idx].material.emissiveIntensity = 0.7;
          buttonLights[idx].intensity = isMobile ? 1.2 : 1.5;
        }
        if (intersects.length > 0 && intersects[0].object.visible) {
          lastHoveredButton = intersects[0].object;
          const idx = lastHoveredButton.userData.doorIndex;
          buttonMeshes[idx].material.emissiveIntensity = 1.3;
          buttonTextMeshes[idx].visible = true;
          doors[idx].material.emissiveIntensity = 1.0;
          buttonLights[idx].intensity = isMobile ? 1.8 : 2.0;
        } else {
          lastHoveredButton = null;
        }
      }
      window.addEventListener('mousemove', (event) => updateMouseOrTouch(event));
      window.addEventListener('touchstart', (event) => {
        event.preventDefault();
        updateMouseOrTouch(event, true);
      }, { passive: false });
      window.addEventListener('click', (event) => handleInteraction(event));
      window.addEventListener('touchend', (event) => {
        event.preventDefault();
        handleInteraction(event, true);
      }, { passive: false });
      function handleInteraction(event, isTouch = false) {
        const clientX = isTouch ? event.changedTouches[0].clientX : event.clientX;
        const clientY = isTouch ? event.changedTouches[0].clientY : event.clientY;
        console.log(`Interacci贸n detectada en: x=${clientX}, y=${clientY}`);
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (clientY / window.innerHeight) * 2 + 1;
        console.log(`Coordenadas normalizadas: x=${mouse.x}, y=${mouse.y}`);
        console.log(`Puerta actual: ${doorTitles[currentDoorIndex]}, visible: ${doors[currentDoorIndex].visible}, bot贸n visible: ${buttonMeshes[currentDoorIndex].visible}`);
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(buttonMeshes[currentDoorIndex], true);
        console.log(`Intersecciones con bot贸n de ${doorTitles[currentDoorIndex]}: ${intersects.length}`, intersects.map(i => ({
          doorIndex: i.object.userData.doorIndex,
          door: doorTitles[i.object.userData.doorIndex],
          visible: i.object.visible
        })));
        if (intersects.length > 0 && intersects[0].object.visible) {
          const doorIndex = intersects[0].object.userData.doorIndex;
          console.log(`Bot贸n clicado para puerta: ${doorTitles[doorIndex]}`);
          try {
            doorFrame.src = `puerta${doorIndex + 1}.html?id=${userId}`;
            doorFrame.style.display = 'block';
            doorFrame.style.opacity = '1';
            doorFrame.classList.add('show');
            setTimeout(() => doorFrame.classList.remove('show'), 200);
            doors[doorIndex].visible = false;
            labelMeshes[doorIndex].visible = false;
            buttonMeshes[doorIndex].visible = false;
            buttonTextMeshes[doorIndex].visible = false;
            buttonLights[doorIndex].visible = false;
            buttonEdges[doorIndex].visible = false;
            rainParticles.forEach(p => p.visible = false);
            doors[doorIndex].material.emissiveIntensity = 1.5;
            setTimeout(() => {
              doors[doorIndex].material.emissiveIntensity = 0.7;
            }, 200);
            doorStates[doorIndex].opened = true;
            console.log(`Cargando panel: puerta${doorIndex + 1}.html?id=${userId}`);
          } catch (error) {
            console.error(`Error al cargar puerta${doorIndex + 1}.html?id=${userId}:`, error);
          }
        } else {
          console.warn(`No se detect贸 el bot贸n de ${doorTitles[currentDoorIndex]} o no est谩 visible`);
        }
      }
      doorFrame.onerror = () => {
        console.error(`Error al cargar el iframe: ${doorFrame.src}`);
      };
      let timeElapsed = 0;
      let panelHidden = false;
      let isStopped = false;
      let isResetting = false;
      let resetStartTime = 0;
      let currentDoorIndex = 0;
      const doorStates = doorTitles.map(() => ({ z: doorPosition, opened: false }));
      function updateRendererSize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', updateRendererSize);
      window.addEventListener('orientationchange', updateRendererSize);
      window.addEventListener('message', (event) => {
        console.log('Mensaje recibido:', event.data);
        if (event.data.type === 'zoomUpdate') {
          console.log(`Mensaje zoomUpdate recibido: zoom=${event.data.zoom}`);
          const zoom = event.data.zoom;
          const entryZoom = 1.2;
          const maxZoom = 5.0;
          let frac = zoom > entryZoom ? Math.min(1, (zoom - entryZoom) / (maxZoom - entryZoom)) : 0;
          blackHoleFrame.style.opacity = 1 - frac;
          if (zoom >= 4.9 && !panelHidden) {
            blackHoleFrame.style.display = 'none';
            panelHidden = true;
            doors[0].visible = true;
            labelMeshes[0].visible = true;
            buttonMeshes[0].visible = true;
            buttonTextMeshes[0].visible = false;
            buttonLights[0].visible = true;
            buttonEdges[0].visible = true;
            rainParticles.forEach((p, i) => {
              p.visible = true;
              p.material.color.set(doorColors[0]);
              if (p.userData.type < 3) {
                const ctx = p.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, p.material.map.image.width, p.material.map.image.height);
                ctx.fillStyle = '#' + doorColors[0].toString(16).padStart(6, '0');
                ctx.font = isMobile ? '48px sans-serif' : '64px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emojiList[p.userData.type], p.material.map.image.width / 2, p.material.map.image.height / 2);
                p.material.map.needsUpdate = true;
              }
            });
            isStopped = false;
            console.log(`Panel inicial oculto, mostrando puerta: ${doorTitles[0]}`);
          }
        } else if (event.data.type === 'doorClosed') {
          console.log(`Mensaje doorClosed recibido, puerta actual: ${doorTitles[currentDoorIndex]}`);
          if (currentDoorIndex < doorTitles.length - 1) {
            isResetting = true;
            resetStartTime = timeElapsed;
            doorFrame.style.opacity = '1';
            currentDoorIndex = Math.min(currentDoorIndex + 1, doorTitles.length - 1);
            console.log(`Preparando siguiente puerta: ${doorTitles[currentDoorIndex]}`);
            doors.forEach((door, i) => {
              door.visible = i === currentDoorIndex;
              labelMeshes[i].visible = i === currentDoorIndex;
              labelMeshes[i].material.opacity = 0.5;
              buttonMeshes[i].visible = i === currentDoorIndex;
              buttonTextMeshes[i].visible = false;
              buttonLights[i].visible = i === currentDoorIndex;
              buttonEdges[i].visible = i === currentDoorIndex;
            });
            rainParticles.forEach((p, i) => {
              p.visible = i === currentDoorIndex;
              p.position.set(
                (Math.random() - 0.5) * tunnelRadius * 1.8,
                tunnelRadius * 1.2,
                doorPosition + (Math.random() - 0.5) * tunnelRadius * 0.5
              );
              p.material.color.set(doorColors[currentDoorIndex]);
              if (p.userData.type < 3) {
                const ctx = p.material.map.image.getContext('2d');
                ctx.clearRect(0, 0, p.material.map.image.width, p.material.map.image.height);
                ctx.fillStyle = '#' + doorColors[currentDoorIndex].toString(16).padStart(6, '0');
                ctx.font = isMobile ? '48px sans-serif' : '64px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emojiList[p.userData.type], p.material.map.image.width / 2, p.material.map.image.height / 2);
                p.material.map.needsUpdate = true;
              }
            });
            setTimeout(() => {
              labelMeshes[currentDoorIndex].material.opacity = 1.0;
            }, 500);
          } else {
            doorFrame.style.opacity = '0';
            rainParticles.forEach(p => p.visible = false);
            setTimeout(() => {
              doorFrame.style.display = 'none';
              doorFrame.src = '';
              console.log('ltima puerta cerrada, ocultando panel');
            }, 500);
          }
        }
      });
      let last = performance.now();
      function render() {
        requestAnimationFrame(render);
        const now = performance.now();
        const dt = (now - last) / 1000;
        last = now;
        timeElapsed += dt;
        if (timeElapsed > 10 && !panelHidden) {
          blackHoleFrame.style.opacity = 0;
          setTimeout(() => {
            blackHoleFrame.style.display = 'none';
            panelHidden = true;
            doors[0].visible = true;
            labelMeshes[0].visible = true;
            buttonMeshes[0].visible = true;
            buttonTextMeshes[0].visible = false;
            buttonLights[0].visible = true;
            buttonEdges[0].visible = true;
            rainParticles.forEach(p => p.visible = true);
            isStopped = false;
            console.log(`Mostrando puerta inicial: ${doorTitles[0]}`);
          }, 500);
        }
        if (isResetting) {
          const resetDuration = 0.5;
          const resetProgress = Math.min((timeElapsed - resetStartTime) / resetDuration, 1);
          camera.position.z = (doorPosition + 200) + (30 - (doorPosition + 200)) * resetProgress;
          if (resetProgress >= 1) {
            isResetting = false;
            doorFrame.style.opacity = '0';
            setTimeout(() => {
              doorFrame.style.display = 'none';
              doorFrame.src = '';
              if (currentDoorIndex < doorTitles.length) {
                doors.forEach((door, i) => {
                  door.visible = i === currentDoorIndex;
                  labelMeshes[i].visible = i === currentDoorIndex;
                  labelMeshes[i].material.opacity = 0.5;
                  buttonMeshes[i].visible = i === currentDoorIndex;
                  buttonTextMeshes[i].visible = false;
                  buttonLights[i].visible = i === currentDoorIndex;
                  buttonEdges[i].visible = i === currentDoorIndex;
                });
                rainParticles.forEach((p, i) => {
                  p.visible = i === currentDoorIndex;
                  p.position.set(
                    (Math.random() - 0.5) * tunnelRadius * 1.8,
                    tunnelRadius * 1.2,
                    doorPosition + (Math.random() - 0.5) * tunnelRadius * 0.5
                  );
                  p.material.color.set(doorColors[currentDoorIndex]);
                  if (p.userData.type < 3) {
                    const ctx = p.material.map.image.getContext('2d');
                    ctx.clearRect(0, 0, p.material.map.image.width, p.material.map.image.height);
                    ctx.fillStyle = '#' + doorColors[currentDoorIndex].toString(16).padStart(6, '0');
                    ctx.font = isMobile ? '48px sans-serif' : '64px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(emojiList[p.userData.type], p.material.map.image.width / 2, p.material.map.image.height / 2);
                    p.material.map.needsUpdate = true;
                  }
                });
                isStopped = false;
                console.log(`Mostrando puerta: ${doorTitles[currentDoorIndex]}, posici贸n z: ${camera.position.z}`);
                setTimeout(() => {
                  labelMeshes[currentDoorIndex].material.opacity = 1.0;
                }, 500);
              }
            }, 500);
          }
        }
        if (panelHidden && !isStopped && !isResetting && currentDoorIndex < doorStates.length && !doorStates[currentDoorIndex].opened) {
          const targetZ = doorStates[currentDoorIndex].z + 200;
          camera.position.z += (targetZ - camera.position.z) * 0.02 * dt * 60;
          if (Math.abs(targetZ - camera.position.z) < 10) {
            isStopped = true;
            console.log(`Zoom completado para puerta: ${doorTitles[currentDoorIndex]}, posici贸n z: ${camera.position.z}`);
          }
        }
        rainParticles.forEach(p => {
          if (p.visible && timeElapsed > p.userData.startTime) {
            p.position.y += p.userData.velocity * dt;
            if (p.position.y < -tunnelRadius * 1.2) {
              p.position.y = tunnelRadius * 1.2;
              p.position.x = (Math.random() - 0.5) * tunnelRadius * 1.8;
              p.position.z = doorPosition + (Math.random() - 0.5) * tunnelRadius * 0.5;
              p.userData.startTime = timeElapsed + Math.random() * 2;
            }
            p.rotation.z += 0.5 * dt;
          }
        });
        pointsMat.uniforms.uTime.value = now * 0.001;
        buttonMeshes.forEach((mesh, i) => {
          mesh.position.y = -tunnelRadius * 0.15 + Math.sin(now * 0.001) * tunnelRadius * 0.015;
          buttonLights[i].position.y = mesh.position.y;
          buttonEdges[i].position.y = mesh.position.y;
        });
        labelMeshes.forEach((mesh) => {
          mesh.position.y = tunnelRadius * 0.15 + Math.sin(now * 0.001) * tunnelRadius * 0.02;
        });
        renderer.render(scene, camera);
      }
      render();
    })();
  </script>
</body>
</html>
